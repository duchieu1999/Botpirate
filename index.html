<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hiếu Gà - Hoa Đua Sắc</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#FF6B9D',
                        secondary: '#8A4FFF',
                        accent: '#FFD166',
                        background: '#FFFAFC',
                        success: '#06D6A0',
                        danger: '#EF476F',
                        dark: {
                            primary: '#FF4D8D',
                            secondary: '#7839FF',
                            background: '#241C2C',
                            text: '#F0E6FF'
                        }
                    },
                    animation: {
                        'float': 'float 3s ease-in-out infinite',
                        'shine': 'shine 1.5s ease-in-out infinite',
                        'flower-rotate': 'flower-rotate 8s linear infinite',
                        'bounce-slow': 'bounce 2s ease-in-out infinite'
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' }
                        },
                        shine: {
                            '0%': { opacity: '0.5' },
                            '50%': { opacity: '1' },
                            '100%': { opacity: '0.5' }
                        },
                        'flower-rotate': {
                            '0%': { transform: 'rotate(0deg)' },
                            '100%': { transform: 'rotate(360deg)' }
                        }
                    }
                }
            }
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            overflow: hidden;
            touch-action: none;
            background-color: #FFFAFC;
            color: #333;
            position: relative;
        }

        .dark body {
            background-color: #241C2C;
            color: #F0E6FF;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        .joystick-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            z-index: 50;
            touch-action: none;
            opacity: 0.7;
        }

        .joystick-background {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .joystick-thumb {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .chicken-logo {
            position: relative;
            width: 180px;
            height: 180px;
            margin: 0 auto;
        }

        .chicken-body {
            width: 100px;
            height: 100px;
            background-color: #FFC36B;
            border-radius: 50%;
            position: absolute;
            top: 50px;
            left: 50px;
            z-index: 1;
        }

        .chicken-head {
            width: 70px;
            height: 70px;
            background-color: #FFA500;
            border-radius: 50%;
            position: absolute;
            top: 30px;
            left: 70px;
            z-index: 2;
        }

        .chicken-eye {
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 3;
        }

        .chicken-eye::after {
            content: '';
            width: 10px;
            height: 10px;
            background-color: black;
            border-radius: 50%;
            position: absolute;
            top: 5px;
            left: 5px;
        }

        .chicken-comb {
            width: 15px;
            height: 30px;
            background-color: #FF5555;
            position: absolute;
            top: -25px;
            left: 30px;
            border-radius: 10px 10px 0 0;
            z-index: 2;
        }

        .chicken-beak {
            width: 30px;
            height: 15px;
            background-color: #FF9500;
            position: absolute;
            top: 35px;
            left: 55px;
            border-radius: 50%;
            transform: rotate(10deg);
            z-index: 3;
        }

        .chicken-legs {
            width: 10px;
            height: 30px;
            background-color: #FF9500;
            position: absolute;
            bottom: -25px;
            left: 70px;
            z-index: 0;
        }

        .chicken-legs::before {
            content: '';
            width: 10px;
            height: 30px;
            background-color: #FF9500;
            position: absolute;
            bottom: 0;
            left: -30px;
        }

        .chicken-wing {
            width: 40px;
            height: 60px;
            background-color: #FFDB99;
            border-radius: 50% 50% 0 50%;
            position: absolute;
            top: 60px;
            left: 20px;
            transform: rotate(-30deg);
            z-index: 0;
        }

        .flower {
            position: absolute;
            width: 40px;
            height: 40px;
        }

        .petal {
            width: 15px;
            height: 15px;
            background-color: #FF6B9D;
            border-radius: 50%;
            position: absolute;
        }

        .petal:nth-child(1) { top: 0; left: 12.5px; }
        .petal:nth-child(2) { top: 6px; left: 22px; }
        .petal:nth-child(3) { top: 12.5px; left: 25px; }
        .petal:nth-child(4) { top: 22px; left: 22px; }
        .petal:nth-child(5) { top: 25px; left: 12.5px; }
        .petal:nth-child(6) { top: 22px; left: 3px; }
        .petal:nth-child(7) { top: 12.5px; left: 0; }
        .petal:nth-child(8) { top: 6px; left: 3px; }

        .flower-center {
            width: 15px;
            height: 15px;
            background-color: #FFD166;
            border-radius: 50%;
            position: absolute;
            top: 12.5px;
            left: 12.5px;
            z-index: 2;
        }

        .flower-alt .petal {
            background-color: #8A4FFF;
        }

        .flower-alt-2 .petal {
            background-color: #06D6A0;
        }

        .bouncing-btn {
            animation: bounce-slow 2s infinite;
        }
        
        @keyframes bounce-slow {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .border-pulse {
            animation: border-pulse 2s infinite;
        }
        
        @keyframes border-pulse {
            0%, 100% { border-color: rgba(255, 107, 157, 0.5); }
            50% { border-color: rgba(255, 107, 157, 1); }
        }
        
        .typing-animation::after {
            content: '|';
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .player {
            position: absolute;
            width: 50px;
            height: 50px;
            transition: transform 0.1s linear;
        }

        .player-avatar {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
        }

        .player-name {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 3px #FFF, 0 0 3px #FFF, 0 0 3px #FFF;
        }

        .player-health {
            position: absolute;
            bottom: -10px;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: #ccc;
            border-radius: 2px;
        }

        .player-health-inner {
            height: 100%;
            background-color: #06D6A0;
            border-radius: 2px;
            transition: width 0.3s;
        }

        .game-item {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            z-index: 5;
        }

        .safe-zone {
            position: absolute;
            border: 2px dashed #8A4FFF;
            border-radius: 50%;
            opacity: 0.7;
            pointer-events: none;
            z-index: 5;
        }

        .danger-zone {
            position: absolute;
            background-color: rgba(239, 71, 111, 0.2);
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
        }

        #flowers-collected {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 20;
            font-size: 18px;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 10px;
        }

        #players-count {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 20;
            font-size: 18px;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 10px;
        }

        #countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 25;
            font-size: 80px;
            font-weight: bold;
            color: #FF6B9D;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #FF6B9D;
            opacity: 0.8;
            z-index: 100;
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splash-screen" class="fixed inset-0 flex flex-col items-center justify-center bg-background dark:bg-dark-background z-50">
        <div class="chicken-logo animate-float mb-4">
            <div class="chicken-body"></div>
            <div class="chicken-wing"></div>
            <div class="chicken-head">
                <div class="chicken-eye"></div>
                <div class="chicken-comb"></div>
                <div class="chicken-beak"></div>
            </div>
            <div class="chicken-legs"></div>
        </div>
        <h1 class="text-3xl font-bold text-primary dark:text-dark-primary mb-2">Hiếu Gà</h1>
        <h2 class="text-xl font-semibold text-secondary dark:text-dark-secondary mb-6">Hoa Đua Sắc</h2>
        <p class="text-gray-600 dark:text-dark-text mb-8 text-center px-4">Chào mừng ngày 8/3! <br>Hãy cùng tham gia trận chiến sắc hoa!</p>
        <button id="play-button" class="bg-primary hover:bg-opacity-90 text-white font-bold py-3 px-8 rounded-full shadow-lg transform transition duration-300 hover:scale-105 bouncing-btn">
            Bắt Đầu Chơi
        </button>
        
        <div class="mt-8 flex justify-center space-x-2">
            <div class="flower animate-flower-rotate">
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="flower-center"></div>
            </div>
            <div class="flower flower-alt animate-flower-rotate" style="animation-delay: 0.5s">
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="flower-center"></div>
            </div>
            <div class="flower flower-alt-2 animate-flower-rotate" style="animation-delay: 1s">
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="petal"></div>
                <div class="flower-center"></div>
            </div>
        </div>
    </div>

    <!-- Lobby Screen -->
    <div id="lobby-screen" class="fixed inset-0 flex flex-col items-center justify-center bg-background dark:bg-dark-background z-40 hidden">
        <div class="w-full max-w-md p-6 bg-white dark:bg-dark-background rounded-xl shadow-lg">
            <div class="flex items-center justify-center mb-6">
                <div class="chicken-logo" style="transform: scale(0.6);">
                    <div class="chicken-body"></div>
                    <div class="chicken-wing"></div>
                    <div class="chicken-head">
                        <div class="chicken-eye"></div>
                        <div class="chicken-comb"></div>
                        <div class="chicken-beak"></div>
                    </div>
                    <div class="chicken-legs"></div>
                </div>
                <div>
                    <h2 class="text-2xl font-bold text-primary dark:text-dark-primary">Hiếu Gà</h2>
                    <h3 class="text-lg font-semibold text-secondary dark:text-dark-secondary">Hoa Đua Sắc</h3>
                </div>
            </div>

            <div class="mb-6">
                <label for="player-name" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Tên của bạn:</label>
                <input type="text" id="player-name" class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 dark:text-white text-base" placeholder="Nhập tên của bạn" maxlength="10">
            </div>

            <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Chọn màu nhân vật:</label>
                <div class="flex flex-wrap gap-2 justify-center">
                    <div class="w-10 h-10 rounded-full bg-pink-500 cursor-pointer color-option border-2 border-transparent hover:border-gray-400" data-color="#EC4899"></div>
                    <div class="w-10 h-10 rounded-full bg-purple-500 cursor-pointer color-option border-2 border-transparent hover:border-gray-400" data-color="#8B5CF6"></div>
                    <div class="w-10 h-10 rounded-full bg-blue-500 cursor-pointer color-option border-2 border-transparent hover:border-gray-400" data-color="#3B82F6"></div>
                    <div class="w-10 h-10 rounded-full bg-green-500 cursor-pointer color-option border-2 border-transparent hover:border-gray-400" data-color="#10B981"></div>
                    <div class="w-10 h-10 rounded-full bg-yellow-500 cursor-pointer color-option border-2 border-transparent hover:border-gray-400" data-color="#F59E0B"></div>
                    <div class="w-10 h-10 rounded-full bg-red-500 cursor-pointer color-option border-2 border-transparent hover:border-gray-400" data-color="#EF4444"></div>
                </div>
            </div>

            <div class="flex flex-col gap-4">
                <button id="create-room-btn" class="w-full bg-primary hover:bg-opacity-90 text-white font-bold py-3 px-6 rounded-lg shadow transition duration-300">
                    Tạo phòng mới
                </button>
                <div class="relative">
                    <input type="text" id="room-code" class="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 dark:text-white text-base" placeholder="Nhập mã phòng">
                    <button id="join-room-btn" class="absolute right-2 top-1/2 transform -translate-y-1/2 bg-secondary hover:bg-opacity-90 text-white font-bold py-2 px-4 rounded-lg transition duration-300">
                        Vào
                    </button>
                </div>
            </div>
        </div>

        <div id="waiting-room" class="w-full max-w-md p-6 bg-white dark:bg-dark-background rounded-xl shadow-lg mt-4 hidden">
            <h3 class="text-xl font-bold text-center mb-4">Phòng chờ</h3>
            <div class="mb-4 flex justify-between items-center">
                <span>Mã phòng: </span>
                <span id="room-code-display" class="font-mono bg-gray-100 dark:bg-gray-700 px-3 py-1 rounded">ABCDE</span>
                <button id="copy-code-btn" class="text-secondary dark:text-dark-secondary hover:text-opacity-80">Sao chép</button>
            </div>
            
            <div class="mb-6">
                <h4 class="font-semibold mb-2">Người chơi (<span id="player-count">1</span>/5):</h4>
                <ul id="players-list" class="space-y-2 max-h-40 overflow-y-auto">
                    <!-- Players will be added here dynamically -->
                </ul>
            </div>
            
            <div class="text-center">
                <button id="start-game-btn" class="bg-success hover:bg-opacity-90 text-white font-bold py-2 px-6 rounded-lg shadow transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed hidden">
                    Bắt đầu trò chơi
                </button>
                <p id="waiting-message" class="text-gray-600 dark:text-gray-400 font-medium typing-animation">Đang chờ người chơi khác...</p>
            </div>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="fixed inset-0 bg-background dark:bg-dark-background z-30 hidden">
        <canvas id="game-canvas"></canvas>
        <div id="flowers-collected">Hoa: 0</div>
        <div id="players-count">Người chơi: 0/5</div>
        <div id="countdown">3</div>
        
        <div class="joystick-container">
            <div class="joystick-background"></div>
            <div class="joystick-thumb"></div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="fixed inset-0 flex flex-col items-center justify-center bg-background dark:bg-dark-background z-35 hidden">
        <h2 class="text-3xl font-bold text-primary dark:text-dark-primary mb-4">Trò chơi kết thúc!</h2>
        <div id="game-result" class="text-2xl font-semibold mb-6">Kết quả</div>
        
        <div id="winners-list" class="w-full max-w-md p-6 bg-white dark:bg-gray-800 rounded-xl shadow-lg mb-8">
            <h3 class="text-xl font-bold mb-4 text-center">Top 3 người thắng cuộc</h3>
            <div class="space-y-4" id="winners-container">
                <!-- Winners will be dynamically added here -->
            </div>
        </div>
        
        <button id="play-again-btn" class="bg-primary hover:bg-opacity-90 text-white font-bold py-3 px-8 rounded-full shadow-lg transform transition duration-300 hover:scale-105">
            Chơi lại
        </button>
    </div>

    <script>
        // Check for dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Game variables
        let canvas, ctx;
        let playerColor = "#EC4899"; // Default color
        let playerName = "";
        let roomCode = "";
        let isHost = false;
        let gameStarted = false;
        let gameOver = false;
        
        // Player and game state
        let player = {
            id: generateId(),
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            speed: 5,
            color: playerColor,
            name: "",
            health: 100,
            flowers: 0,
            alive: true
        };
        
        let otherPlayers = {};
        let flowers = [];
        let obstacles = [];
        let safeZone = { x: 0, y: 0, radius: 0, nextRadius: 0 };
        let gameAreaWidth = 2000;
        let gameAreaHeight = 2000;
        
        // Touch controls
        let joystick = {
            active: false,
            startX: 0,
            startY: 0,
            moveX: 0,
            moveY: 0,
            deltaX: 0,
            deltaY: 0
        };
        
        // WebSocket simulation for preview
        let mockSocket = {
            readyState: 0, // 0 = CONNECTING, 1 = OPEN
            onopen: null,
            onmessage: null,
            onclose: null,
            onerror: null,
            
            send: function(data) {
                console.log("Sending data:", data);
                
                // Simulate server response
                const message = JSON.parse(data);
                
                setTimeout(() => {
                    if (this.readyState === 1) {
                        switch(message.type) {
                            case "join":
                                this._simulateJoin(message);
                                break;
                            case "create":
                                this._simulateCreate(message);
                                break;
                            case "start":
                                this._simulateStart(message);
                                break;
                            case "move":
                                this._simulateMove(message);
                                break;
                            case "collectFlower":
                                this._simulateCollectFlower(message);
                                break;
                        }
                    }
                }, 200);
            },
            
            close: function() {
                this.readyState = 3; // CLOSED
                if (this.onclose) this.onclose({ code: 1000 });
            },
            
            connect: function() {
                this.readyState = 0; // CONNECTING
                
                setTimeout(() => {
                    this.readyState = 1; // OPEN
                    if (this.onopen) this.onopen();
                }, 500);
            },
            
            // Simulation methods
            _simulateJoin: function(message) {
                const room = message.room;
                if (room === "DEMO" || room === "TEST") {
                    // Create some fake players
                    const fakePlayers = [
                        { id: generateId(), name: "Hạnh Hoa", color: "#8B5CF6" },
                        { id: generateId(), name: "Lan Anh", color: "#3B82F6" },
                        { id: generateId(), name: "Thanh Xuân", color: "#10B981" }
                    ];
                    
                    // Send join success
                    this._sendMessage({
                        type: "joinSuccess",
                        room: room,
                        players: [...fakePlayers, {
                            id: player.id,
                            name: message.player.name,
                            color: message.player.color
                        }],
                        isHost: false
                    });
                    
                    // Notify other players
                    setTimeout(() => {
                        this._sendMessage({
                            type: "playerJoined",
                            player: {
                                id: fakePlayers[0].id,
                                name: fakePlayers[0].name,
                                color: fakePlayers[0].color
                            }
                        });
                    }, 2000);
                } else {
                    // Simulate error for invalid room
                    this._sendMessage({
                        type: "error",
                        message: "Không tìm thấy phòng!"
                    });
                }
            },
            
            _simulateCreate: function(message) {
                this._sendMessage({
                    type: "createSuccess",
                    room: "DEMO",
                    players: [{
                        id: player.id,
                        name: message.player.name,
                        color: message.player.color
                    }],
                    isHost: true
                });
            },
            
            _simulateStart: function(message) {
                // Generate game map and items
                const gameMap = this._generateGameMap();
                
                this._sendMessage({
                    type: "gameStart",
                    map: gameMap,
                    countdown: 3
                });
            },
            
            _simulateMove: function(message) {
                // For demo, we'll simulate movement of other players
                const playerId = message.player.id;
                
                // Only echo back the player's own movement
                if (playerId === player.id) {
                    this._sendMessage({
                        type: "playerMove",
                        playerId: playerId,
                        x: message.x,
                        y: message.y,
                        vx: message.vx,
                        vy: message.vy
                    });
                }
                
                // Simulate other players movement
                for (const id in otherPlayers) {
                    if (id !== player.id) {
                        // Random movement
                        const randomX = otherPlayers[id].x + (Math.random() * 20 - 10);
                        const randomY = otherPlayers[id].y + (Math.random() * 20 - 10);
                        
                        // Keep within boundaries
                        const constrainedX = Math.max(50, Math.min(gameAreaWidth - 50, randomX));
                        const constrainedY = Math.max(50, Math.min(gameAreaHeight - 50, randomY));
                        
                        this._sendMessage({
                            type: "playerMove",
                            playerId: id,
                            x: constrainedX,
                            y: constrainedY,
                            vx: constrainedX - otherPlayers[id].x,
                            vy: constrainedY - otherPlayers[id].y
                        });
                        
                        otherPlayers[id].x = constrainedX;
                        otherPlayers[id].y = constrainedY;
                    }
                }
            },
            
            _simulateCollectFlower: function(message) {
                const flowerIndex = message.flowerIndex;
                
                if (flowerIndex >= 0 && flowerIndex < flowers.length) {
                    // Send collect success
                    this._sendMessage({
                        type: "flowerCollected",
                        playerId: player.id,
                        flowerIndex: flowerIndex,
                        flowerCount: player.flowers + 1
                    });
                    
                    // Generate a new flower
                    setTimeout(() => {
                        const newFlower = this._generateRandomFlower();
                        this._sendMessage({
                            type: "newFlower",
                            flower: newFlower,
                            index: flowerIndex
                        });
                    }, 2000);
                }
            },
            
            _generateGameMap: function() {
                const flowers = [];
                const obstacles = [];
                
                // Generate flowers
                for (let i = 0; i < 20; i++) {
                    flowers.push({
                        x: Math.random() * (gameAreaWidth - 100) + 50,
                        y: Math.random() * (gameAreaHeight - 100) + 50,
                        type: Math.floor(Math.random() * 3)
                    });
                }
                
                // Generate obstacles
                for (let i = 0; i < 10; i++) {
                    obstacles.push({
                        x: Math.random() * (gameAreaWidth - 200) + 100,
                        y: Math.random() * (gameAreaHeight - 200) + 100,
                        radius: Math.random() * 30 + 20
                    });
                }
                
                // Setup safe zone
                const safeZone = {
                    x: gameAreaWidth / 2,
                    y: gameAreaHeight / 2,
                    radius: gameAreaWidth / 2,
                    nextRadius: gameAreaWidth / 2.5
                };
                
                // Setup player positions
                const playerPositions = {};
                
                // Main player
                playerPositions[player.id] = {
                    x: gameAreaWidth / 2 + (Math.random() * 200 - 100),
                    y: gameAreaHeight / 2 + (Math.random() * 200 - 100)
                };
                
                // Other players
                for (const id in otherPlayers) {
                    playerPositions[id] = {
                        x: gameAreaWidth / 2 + (Math.random() * 400 - 200),
                        y: gameAreaHeight / 2 + (Math.random() * 400 - 200)
                    };
                }
                
                return {
                    width: gameAreaWidth,
                    height: gameAreaHeight,
                    flowers: flowers,
                    obstacles: obstacles,
                    safeZone: safeZone,
                    playerPositions: playerPositions
                };
            },
            
            _generateRandomFlower: function() {
                return {
                    x: Math.random() * (gameAreaWidth - 100) + 50,
                    y: Math.random() * (gameAreaHeight - 100) + 50,
                    type: Math.floor(Math.random() * 3)
                };
            },
            
            _sendMessage: function(data) {
                if (this.onmessage) {
                    this.onmessage({ data: JSON.stringify(data) });
                }
            }
        };
        
        // Initialize WebSocket (will be mockSocket for Canvas preview)
        let socket = mockSocket;
        
        // UI Elements
        const splashScreen = document.getElementById('splash-screen');
        const lobbyScreen = document.getElementById('lobby-screen');
        const gameScreen = document.getElementById('game-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const playButton = document.getElementById('play-button');
        const playerNameInput = document.getElementById('player-name');
        const colorOptions = document.querySelectorAll('.color-option');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const roomCodeInput = document.getElementById('room-code');
        const waitingRoom = document.getElementById('waiting-room');
        const roomCodeDisplay = document.getElementById('room-code-display');
        const copyCodeBtn = document.getElementById('copy-code-btn');
        const playerCountElement = document.getElementById('player-count');
        const playersList = document.getElementById('players-list');
        const startGameBtn = document.getElementById('start-game-btn');
        const waitingMessage = document.getElementById('waiting-message');
        const flowersCollected = document.getElementById('flowers-collected');
        const playersCount = document.getElementById('players-count');
        const countdownElement = document.getElementById('countdown');
        const playAgainBtn = document.getElementById('play-again-btn');
        const gameResult = document.getElementById('game-result');
        const winnersContainer = document.getElementById('winners-container');
        
        // Game initialization
        function initGame() {
            // Setup canvas
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Initialize joystick
            initJoystick();
            
            // Setup event listeners
            playButton.addEventListener('click', showLobby);
            
            colorOptions.forEach(option => {
                option.addEventListener('click', function() {
                    colorOptions.forEach(opt => opt.classList.remove('border-primary', 'border-2'));
                    this.classList.add('border-primary', 'border-2');
                    playerColor = this.getAttribute('data-color');
                    player.color = playerColor;
                });
            });
            
            createRoomBtn.addEventListener('click', createRoom);
            joinRoomBtn.addEventListener('click', joinRoom);
            copyCodeBtn.addEventListener('click', copyRoomCode);
            startGameBtn.addEventListener('click', startGame);
            playAgainBtn.addEventListener('click', returnToLobby);
            
            // Select the first color by default
            colorOptions[0].click();
            
            // Setup window resize event
            window.addEventListener('resize', handleResize);
        }
        
        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        function initJoystick() {
            const joystickContainer = document.querySelector('.joystick-container');
            const joystickThumb = document.querySelector('.joystick-thumb');
            
            // Touch events for joystick
            joystickContainer.addEventListener('touchstart', handleJoystickStart);
            joystickContainer.addEventListener('touchmove', handleJoystickMove);
            joystickContainer.addEventListener('touchend', handleJoystickEnd);
            
            // Mouse events for joystick (for testing on desktop)
            joystickContainer.addEventListener('mousedown', handleJoystickStart);
            document.addEventListener('mousemove', handleJoystickMove);
            document.addEventListener('mouseup', handleJoystickEnd);
        }
        
        function handleJoystickStart(e) {
            e.preventDefault();
            joystick.active = true;
            
            const container = document.querySelector('.joystick-container');
            const rect = container.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Get touch or mouse position
            if (e.type === 'touchstart') {
                joystick.startX = e.touches[0].clientX;
                joystick.startY = e.touches[0].clientY;
            } else { // mousedown
                joystick.startX = e.clientX;
                joystick.startY = e.clientY;
            }
            
            joystick.moveX = joystick.startX;
            joystick.moveY = joystick.startY;
            updateJoystickPosition();
        }
        
        function handleJoystickMove(e) {
            if (!joystick.active) return;
            e.preventDefault();
            
            // Get touch or mouse position
            if (e.type === 'touchmove') {
                joystick.moveX = e.touches[0].clientX;
                joystick.moveY = e.touches[0].clientY;
            } else { // mousemove
                joystick.moveX = e.clientX;
                joystick.moveY = e.clientY;
            }
            
            updateJoystickPosition();
        }
        
        function handleJoystickEnd(e) {
            if (!joystick.active) return;
            e.preventDefault();
            
            joystick.active = false;
            joystick.deltaX = 0;
            joystick.deltaY = 0;
            
            // Reset thumb position
            const thumb = document.querySelector('.joystick-thumb');
            thumb.style.transform = 'translate(-50%, -50%)';
            
            // Update player velocity
            player.vx = 0;
            player.vy = 0;
            
            if (gameStarted && !gameOver) {
                sendPlayerMove();
            }
        }
        
        function updateJoystickPosition() {
            const thumb = document.querySelector('.joystick-thumb');
            const container = document.querySelector('.joystick-container');
            const rect = container.getBoundingClientRect();
            
            // Calculate the center of the joystick
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Calculate the distance from the center
            joystick.deltaX = joystick.moveX - centerX;
            joystick.deltaY = joystick.moveY - centerY;
            
            // Limit the joystick movement to the container radius
            const maxDistance = rect.width / 2 - 30; // 30 is half the thumb width
            const distance = Math.sqrt(joystick.deltaX * joystick.deltaX + joystick.deltaY * joystick.deltaY);
            
            if (distance > maxDistance) {
                const angle = Math.atan2(joystick.deltaY, joystick.deltaX);
                joystick.deltaX = Math.cos(angle) * maxDistance;
                joystick.deltaY = Math.sin(angle) * maxDistance;
            }
            
            // Update thumb position
            thumb.style.transform = `translate(calc(-50% + ${joystick.deltaX}px), calc(-50% + ${joystick.deltaY}px))`;
            
            // Update player velocity based on joystick position (normalized)
            if (distance > 0) {
                const normalizedDeltaX = joystick.deltaX / maxDistance;
                const normalizedDeltaY = joystick.deltaY / maxDistance;
                
                player.vx = normalizedDeltaX * player.speed;
                player.vy = normalizedDeltaY * player.speed;
            } else {
                player.vx = 0;
                player.vy = 0;
            }
            
            if (gameStarted && !gameOver) {
                sendPlayerMove();
            }
        }
        
        function showLobby() {
            splashScreen.style.display = 'none';
            lobbyScreen.style.display = 'flex';
        }
        
        function createRoom() {
            playerName = playerNameInput.value.trim() || `Người chơi ${Math.floor(Math.random() * 1000)}`;
            player.name = playerName;
            
            // Connect to WebSocket server
            connectToServer();
            
            socket.onopen = function() {
                // Send create room message
                socket.send(JSON.stringify({
                    type: "create",
                    player: {
                        id: player.id,
                        name: playerName,
                        color: playerColor
                    }
                }));
            };
        }
        
        function joinRoom() {
            playerName = playerNameInput.value.trim() || `Người chơi ${Math.floor(Math.random() * 1000)}`;
            player.name = playerName;
            
            roomCode = roomCodeInput.value.trim().toUpperCase();
            if (!roomCode) {
                alert("Vui lòng nhập mã phòng!");
                return;
            }
            
            // Connect to WebSocket server
            connectToServer();
            
            socket.onopen = function() {
                // Send join room message
                socket.send(JSON.stringify({
                    type: "join",
                    room: roomCode,
                    player: {
                        id: player.id,
                        name: playerName,
                        color: playerColor
                    }
                }));
            };
        }
        
        function connectToServer() {
            // For real implementation, uncomment this line and comment out the mockSocket
             socket = new WebSocket('wss://serversocket-production.up.railway.app');
            
            // For preview, use the mockSocket
            socket = mockSocket;
            socket.connect();
            
            // Setup WebSocket event handlers
            socket.onmessage = handleServerMessage;
            
            socket.onclose = function() {
                console.log('WebSocket connection closed');
                // Handle reconnection or show error message
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                // Show error message
            };
        }
        
        function handleServerMessage(event) {
            const message = JSON.parse(event.data);
            console.log("Received message:", message);
            
            switch(message.type) {
                case "createSuccess":
                    handleCreateSuccess(message);
                    break;
                case "joinSuccess":
                    handleJoinSuccess(message);
                    break;
                case "playerJoined":
                    handlePlayerJoined(message);
                    break;
                case "playerLeft":
                    handlePlayerLeft(message);
                    break;
                case "gameStart":
                    handleGameStart(message);
                    break;
                case "playerMove":
                    handlePlayerMove(message);
                    break;
                case "flowerCollected":
                    handleFlowerCollected(message);
                    break;
                case "newFlower":
                    handleNewFlower(message);
                    break;
                case "updateSafeZone":
                    handleUpdateSafeZone(message);
                    break;
                case "playerHit":
                    handlePlayerHit(message);
                    break;
                case "playerEliminated":
                    handlePlayerEliminated(message);
                    break;
                case "gameOver":
                    handleGameOver(message);
                    break;
                case "error":
                    handleError(message);
                    break;
            }
        }
        
        function handleCreateSuccess(message) {
            roomCode = message.room;
            isHost = message.isHost;
            roomCodeDisplay.textContent = roomCode;
            
            // Initialize other players
            otherPlayers = {};
            message.players.forEach(p => {
                if (p.id !== player.id) {
                    otherPlayers[p.id] = {
                        id: p.id,
                        x: 0,
                        y: 0,
                        vx: 0,
                        vy: 0,
                        color: p.color,
                        name: p.name,
                        health: 100,
                        flowers: 0,
                        alive: true
                    };
                }
            });
            
            // Update UI
            updateLobbyPlayersList(message.players);
            waitingRoom.style.display = 'block';
            
            // Show start button if host
            if (isHost) {
                startGameBtn.style.display = 'block';
                waitingMessage.style.display = 'none';
            }
        }
        
        function handleJoinSuccess(message) {
            roomCode = message.room;
            isHost = message.isHost;
            roomCodeDisplay.textContent = roomCode;
            
            // Initialize other players
            otherPlayers = {};
            message.players.forEach(p => {
                if (p.id !== player.id) {
                    otherPlayers[p.id] = {
                        id: p.id,
                        x: 0,
                        y: 0,
                        vx: 0,
                        vy: 0,
                        color: p.color,
                        name: p.name,
                        health: 100,
                        flowers: 0,
                        alive: true
                    };
                }
            });
            
            // Update UI
            updateLobbyPlayersList(message.players);
            waitingRoom.style.display = 'block';
            
            // Show start button if host
            if (isHost) {
                startGameBtn.style.display = 'block';
                waitingMessage.style.display = 'none';
            }
        }
        
        function handlePlayerJoined(message) {
            const newPlayer = message.player;
            
            // Add to other players if not self
            if (newPlayer.id !== player.id) {
                otherPlayers[newPlayer.id] = {
                    id: newPlayer.id,
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    color: newPlayer.color,
                    name: newPlayer.name,
                    health: 100,
                    flowers: 0,
                    alive: true
                };
                
                // Update UI
                const allPlayers = [player, ...Object.values(otherPlayers)];
                updateLobbyPlayersList(allPlayers);
                
                // Enable start button if host and enough players
                if (isHost && allPlayers.length >= 2) {
                    startGameBtn.disabled = false;
                }
            }
        }
        
        function handlePlayerLeft(message) {
            const playerId = message.playerId;
            
            // Remove from other players
            if (otherPlayers[playerId]) {
                delete otherPlayers[playerId];
                
                // Update UI
                const allPlayers = [player, ...Object.values(otherPlayers)];
                updateLobbyPlayersList(allPlayers);
                
                // Disable start button if not enough players
                if (isHost && allPlayers.length < 2) {
                    startGameBtn.disabled = true;
                }
            }
        }
        
        function handleGameStart(message) {
            // Hide lobby, show game screen
            lobbyScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            
            // Set up game map
            const map = message.map;
            gameAreaWidth = map.width;
            gameAreaHeight = map.height;
            flowers = map.flowers;
            obstacles = map.obstacles;
            safeZone = map.safeZone;
            
            // Set player positions
            player.x = map.playerPositions[player.id].x;
            player.y = map.playerPositions[player.id].y;
            
            for (const id in otherPlayers) {
                if (map.playerPositions[id]) {
                    otherPlayers[id].x = map.playerPositions[id].x;
                    otherPlayers[id].y = map.playerPositions[id].y;
                }
            }
            
            // Start countdown
            startCountdown(message.countdown || 3);
        }
        
        function startCountdown(seconds) {
            let count = seconds;
            countdownElement.textContent = count;
            countdownElement.style.opacity = 1;
            
            const interval = setInterval(() => {
                count--;
                
                if (count > 0) {
                    countdownElement.textContent = count;
                } else {
                    clearInterval(interval);
                    countdownElement.style.opacity = 0;
                    gameStarted = true;
                    
                    // Start game loop
                    requestAnimationFrame(gameLoop);
                    
                    // Start safe zone shrinking
                    scheduleSafeZoneShrink();
                }
            }, 1000);
        }
        
        function scheduleSafeZoneShrink() {
            setTimeout(() => {
                if (!gameOver) {
                    // Simulate server sending safe zone update
                    socket._sendMessage({
                        type: "updateSafeZone",
                        safeZone: {
                            x: safeZone.x,
                            y: safeZone.y,
                            radius: safeZone.nextRadius,
                            nextRadius: safeZone.nextRadius * 0.7
                        }
                    });
                    
                    // Schedule next shrink if not too small
                    if (safeZone.nextRadius * 0.7 > 100) {
                        scheduleSafeZoneShrink();
                    } else {
                        // Game is almost over, start eliminating players outside zone
                        schedulePlayerElimination();
                    }
                }
            }, 20000); // 20 seconds between zone shrinks
        }
        
        function schedulePlayerElimination() {
            const eliminationInterval = setInterval(() => {
                if (gameOver) {
                    clearInterval(eliminationInterval);
                    return;
                }
                
                // Check if only one player left
                const activePlayers = [player, ...Object.values(otherPlayers)].filter(p => p.alive).length;
                if (activePlayers <= 3) {
                    // End the game with remaining players as winners
                    const winners = [player, ...Object.values(otherPlayers)]
                        .filter(p => p.alive)
                        .sort((a, b) => b.flowers - a.flowers);
                    
                    socket._sendMessage({
                        type: "gameOver",
                        winners: winners.map(p => ({
                            id: p.id,
                            name: p.name,
                            color: p.color,
                            flowers: p.flowers
                        }))
                    });
                    
                    clearInterval(eliminationInterval);
                    return;
                }
                
                // Find players outside the safe zone
                for (const id in otherPlayers) {
                    if (otherPlayers[id].alive) {
                        const distance = Math.sqrt(
                            Math.pow(otherPlayers[id].x - safeZone.x, 2) + 
                            Math.pow(otherPlayers[id].y - safeZone.y, 2)
                        );
                        
                        if (distance > safeZone.radius) {
                            // Damage player
                            socket._sendMessage({
                                type: "playerHit",
                                playerId: id,
                                damage: 25
                            });
                        }
                    }
                }
                
                // Check if player is outside safe zone
                if (player.alive) {
                    const distance = Math.sqrt(
                        Math.pow(player.x - safeZone.x, 2) + 
                        Math.pow(player.y - safeZone.y, 2)
                    );
                    
                    if (distance > safeZone.radius) {
                        // Damage player
                        socket._sendMessage({
                            type: "playerHit",
                            playerId: player.id,
                            damage: 25
                        });
                    }
                }
            }, 3000);
        }
        
        function handlePlayerMove(message) {
            const playerId = message.playerId;
            
            if (playerId === player.id) {
                // This is our player, update position
                player.x = message.x;
                player.y = message.y;
            } else if (otherPlayers[playerId]) {
                // Update other player position
                otherPlayers[playerId].x = message.x;
                otherPlayers[playerId].y = message.y;
                otherPlayers[playerId].vx = message.vx;
                otherPlayers[playerId].vy = message.vy;
            }
        }
        
        function handleFlowerCollected(message) {
            const playerId = message.playerId;
            const flowerIndex = message.flowerIndex;
            
            // Remove the flower
            if (flowerIndex >= 0 && flowerIndex < flowers.length) {
                flowers[flowerIndex] = null;
            }
            
            // Update player flower count
            if (playerId === player.id) {
                player.flowers = message.flowerCount;
                flowersCollected.textContent = `Hoa: ${player.flowers}`;
            } else if (otherPlayers[playerId]) {
                otherPlayers[playerId].flowers = message.flowerCount;
            }
        }
        
        function handleNewFlower(message) {
            const flowerIndex = message.index;
            
            // Add new flower
            if (flowerIndex >= 0 && flowerIndex < flowers.length) {
                flowers[flowerIndex] = message.flower;
            }
        }
        
        function handleUpdateSafeZone(message) {
            safeZone = message.safeZone;
        }
        
        function handlePlayerHit(message) {
            const playerId = message.playerId;
            const damage = message.damage;
            
            if (playerId === player.id) {
                player.health -= damage;
                
                if (player.health <= 0) {
                    player.health = 0;
                    
                    // Player eliminated
                    socket._sendMessage({
                        type: "playerEliminated",
                        playerId: player.id
                    });
                }
            } else if (otherPlayers[playerId]) {
                otherPlayers[playerId].health -= damage;
                
                if (otherPlayers[playerId].health <= 0) {
                    otherPlayers[playerId].health = 0;
                    
                    // Other player eliminated
                    socket._sendMessage({
                        type: "playerEliminated",
                        playerId: playerId
                    });
                }
            }
        }
        
        function handlePlayerEliminated(message) {
            const playerId = message.playerId;
            
            if (playerId === player.id) {
                player.alive = false;
                // Show death overlay or message
            } else if (otherPlayers[playerId]) {
                otherPlayers[playerId].alive = false;
            }
            
            // Update players count
            const activePlayers = [player, ...Object.values(otherPlayers)].filter(p => p.alive).length;
            playersCount.textContent = `Người chơi: ${activePlayers}/5`;
        }
        
        function handleGameOver(message) {
            gameOver = true;
            gameStarted = false;
            
            // Display game over screen with winners
            displayWinners(message.winners);
            
            gameScreen.style.display = 'none';
            gameOverScreen.style.display = 'flex';
        }
        
        function handleError(message) {
            console.error("Error:", message.message);
            alert(`Lỗi: ${message.message}`);
        }
        
        function updateLobbyPlayersList(players) {
            // Update player count
            playerCountElement.textContent = players.length;
            playersCount.textContent = `Người chơi: ${players.length}/5`;
            
            // Clear current list
            playersList.innerHTML = '';
            
            // Add each player
            players.forEach(p => {
                const playerItem = document.createElement('li');
                playerItem.className = 'flex items-center';
                
                const playerColor = document.createElement('div');
                playerColor.className = 'w-4 h-4 rounded-full mr-2';
                playerColor.style.backgroundColor = p.color;
                
                const playerName = document.createElement('span');
                playerName.textContent = p.name;
                if (p.id === player.id) {
                    playerName.className = 'font-bold';
                    playerName.textContent += ' (Bạn)';
                }
                
                playerItem.appendChild(playerColor);
                playerItem.appendChild(playerName);
                playersList.appendChild(playerItem);
            });
            
            // Enable start button if host and enough players
            if (isHost) {
                startGameBtn.disabled = players.length < 2;
            }
        }
        
        function copyRoomCode() {
            navigator.clipboard.writeText(roomCode)
                .then(() => {
                    copyCodeBtn.textContent = 'Đã sao chép!';
                    setTimeout(() => {
                        copyCodeBtn.textContent = 'Sao chép';
                    }, 2000);
                })
                .catch(err => {
                    console.error('Failed to copy room code:', err);
                    alert('Không thể sao chép mã phòng. Vui lòng sao chép thủ công.');
                });
        }
        
        function startGame() {
            // Send start game message
            socket.send(JSON.stringify({
                type: "start",
                room: roomCode
            }));
        }
        
        function gameLoop() {
            if (!gameStarted) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update player position
            updatePlayerPosition();
            
            // Draw game
            drawGame();
            
            // Check for collisions
            checkCollisions();
            
            // Request next frame
            requestAnimationFrame(gameLoop);
        }
        
        function updatePlayerPosition() {
            if (!player.alive) return;
            
            // Update position based on velocity
            player.x += player.vx;
            player.y += player.vy;
            
            // Constrain to game boundaries
            player.x = Math.max(25, Math.min(gameAreaWidth - 25, player.x));
            player.y = Math.max(25, Math.min(gameAreaHeight - 25, player.y));
        }
        
        function drawGame() {
            // Calculate the camera offset to center on player
            const cameraOffsetX = canvas.width / 2 - player.x;
            const cameraOffsetY = canvas.height / 2 - player.y;
            
            // Draw danger zone (outside safe zone)
            ctx.beginPath();
            ctx.arc(safeZone.x + cameraOffsetX, safeZone.y + cameraOffsetY, gameAreaWidth, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(239, 71, 111, 0.2)';
            ctx.fill();
            
            // Draw safe zone boundary
            ctx.beginPath();
            ctx.arc(safeZone.x + cameraOffsetX, safeZone.y + cameraOffsetY, safeZone.radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#8A4FFF';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw next safe zone boundary (dashed)
            ctx.beginPath();
            ctx.arc(safeZone.x + cameraOffsetX, safeZone.y + cameraOffsetY, safeZone.nextRadius, 0, Math.PI * 2);
            ctx.strokeStyle = '#06D6A0';
            ctx.setLineDash([2, 4]);
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw obstacles
            obstacles.forEach(obstacle => {
                ctx.beginPath();
                ctx.arc(
                    obstacle.x + cameraOffsetX,
                    obstacle.y + cameraOffsetY,
                    obstacle.radius,
                    0,
                    Math.PI * 2
                );
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fill();
            });
            
            // Draw flowers
            flowers.forEach((flower, index) => {
                if (flower) {
                    drawFlower(
                        flower.x + cameraOffsetX,
                        flower.y + cameraOffsetY,
                        flower.type,
                        index
                    );
                }
            });
            
            // Draw other players
            for (const id in otherPlayers) {
                if (otherPlayers[id].alive) {
                    drawPlayer(
                        otherPlayers[id],
                        cameraOffsetX,
                        cameraOffsetY
                    );
                }
            }
            
            // Draw player
            if (player.alive) {
                drawPlayer(player, cameraOffsetX, cameraOffsetY);
            }
        }
        
        function drawPlayer(player, offsetX, offsetY) {
            // Draw player circle
            ctx.beginPath();
            ctx.arc(
                player.x + offsetX,
                player.y + offsetY,
                25,
                0,
                Math.PI * 2
            );
            ctx.fillStyle = player.color;
            ctx.fill();
            
            // Draw player face (simple eyes and smile)
            const eyeRadius = 5;
            const eyeOffsetX = 8;
            const eyeOffsetY = -5;
            
            // Draw eyes
            ctx.beginPath();
            ctx.arc(
                player.x + offsetX - eyeOffsetX,
                player.y + offsetY + eyeOffsetY,
                eyeRadius,
                0,
                Math.PI * 2
            );
            ctx.fillStyle = 'white';
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(
                player.x + offsetX + eyeOffsetX,
                player.y + offsetY + eyeOffsetY,
                eyeRadius,
                0,
                Math.PI * 2
            );
            ctx.fillStyle = 'white';
            ctx.fill();
            
            // Draw pupils
            ctx.beginPath();
            ctx.arc(
                player.x + offsetX - eyeOffsetX,
                player.y + offsetY + eyeOffsetY,
                eyeRadius / 2,
                0,
                Math.PI * 2
            );
            ctx.fillStyle = 'black';
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(
                player.x + offsetX + eyeOffsetX,
                player.y + offsetY + eyeOffsetY,
                eyeRadius / 2,
                0,
                Math.PI * 2
            );
            ctx.fillStyle = 'black';
            ctx.fill();
            
            // Draw smile
            ctx.beginPath();
            ctx.arc(
                player.x + offsetX,
                player.y + offsetY + 5,
                10,
                0,
                Math.PI,
                false
            );
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw player name
            ctx.font = '12px Arial';
            ctx.fillStyle = 'black';
            ctx.textAlign = 'center';
            ctx.fillText(
                player.name,
                player.x + offsetX,
                player.y + offsetY - 30
            );
            
            // Draw health bar
            const healthBarWidth = 40;
            const healthBarHeight = 5;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(
                player.x + offsetX - healthBarWidth / 2,
                player.y + offsetY + 30,
                healthBarWidth,
                healthBarHeight
            );
            
            ctx.fillStyle = player.health > 30 ? '#06D6A0' : '#EF476F';
            ctx.fillRect(
                player.x + offsetX - healthBarWidth / 2,
                player.y + offsetY + 30,
                healthBarWidth * (player.health / 100),
                healthBarHeight
            );
            
            // Draw flower count
            const flowerSize = 10;
            ctx.font = '10px Arial';
            ctx.fillStyle = 'black';
            
            // Draw flower icon
            ctx.beginPath();
            ctx.arc(
                player.x + offsetX - 15,
                player.y + offsetY + 40,
                flowerSize / 2,
                0,
                Math.PI * 2
            );
            ctx.fillStyle = '#FF6B9D';
            ctx.fill();
            
            // Draw flower count
            ctx.fillStyle = 'black';
            ctx.textAlign = 'left';
            ctx.fillText(
                `x${player.flowers}`,
                player.x + offsetX - 10,
                player.y + offsetY + 43
            );
        }
        
        function drawFlower(x, y, type, index) {
            const size = 15;
            const colors = ['#FF6B9D', '#8A4FFF', '#06D6A0'];
            const color = colors[type % colors.length];
            
            // Draw petals
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const petalX = x + Math.cos(angle) * size;
                const petalY = y + Math.sin(angle) * size;
                
                ctx.beginPath();
                ctx.arc(petalX, petalY, size / 2, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            }
            
            // Draw center
            ctx.beginPath();
            ctx.arc(x, y, size / 2, 0, Math.PI * 2);
            ctx.fillStyle = '#FFD166';
            ctx.fill();
            
            // Animate the flower with a subtle pulsing effect
            const pulseAmount = Math.sin(Date.now() / 500 + index) * 2;
            
            ctx.beginPath();
            ctx.arc(x, y, (size / 4) + pulseAmount, 0, Math.PI * 2);
            ctx.fillStyle = '#FFA500';
            ctx.fill();
        }
        
        function checkCollisions() {
            if (!player.alive) return;
            
            // Check flower collisions
            flowers.forEach((flower, index) => {
                if (flower) {
                    const distance = Math.sqrt(
                        Math.pow(player.x - flower.x, 2) + 
                        Math.pow(player.y - flower.y, 2)
                    );
                    
                    if (distance < 35) { // Player radius + flower radius
                        // Collect flower
                        socket.send(JSON.stringify({
                            type: "collectFlower",
                            playerId: player.id,
                            flowerIndex: index
                        }));
                    }
                }
            });
            
            // Check player-player collisions (for pushing)
            for (const id in otherPlayers) {
                if (otherPlayers[id].alive) {
                    const otherPlayer = otherPlayers[id];
                    const distance = Math.sqrt(
                        Math.pow(player.x - otherPlayer.x, 2) + 
                        Math.pow(player.y - otherPlayer.y, 2)
                    );
                    
                    if (distance < 50) { // Two player radiuses
                        // Calculate push direction
                        const angle = Math.atan2(player.y - otherPlayer.y, player.x - otherPlayer.x);
                        const pushX = Math.cos(angle) * 2;
                        const pushY = Math.sin(angle) * 2;
                        
                        // Apply push to player
                        player.x += pushX;
                        player.y += pushY;
                        
                        // Constrain to game boundaries
                        player.x = Math.max(25, Math.min(gameAreaWidth - 25, player.x));
                        player.y = Math.max(25, Math.min(gameAreaHeight - 25, player.y));
                        
                        // Send updated position
                        sendPlayerMove();
                    }
                }
            }
            
            // Check obstacle collisions
            obstacles.forEach(obstacle => {
                const distance = Math.sqrt(
                    Math.pow(player.x - obstacle.x, 2) + 
                    Math.pow(player.y - obstacle.y, 2)
                );
                
                if (distance < 25 + obstacle.radius) {
                    // Calculate bounce direction
                    const angle = Math.atan2(player.y - obstacle.y, player.x - obstacle.x);
                    const bounceX = Math.cos(angle) * 5;
                    const bounceY = Math.sin(angle) * 5;
                    
                    // Apply bounce to player
                    player.x += bounceX;
                    player.y += bounceY;
                    
                    // Constrain to game boundaries
                    player.x = Math.max(25, Math.min(gameAreaWidth - 25, player.x));
                    player.y = Math.max(25, Math.min(gameAreaHeight - 25, player.y));
                    
                    // Send updated position
                    sendPlayerMove();
                }
            });
        }
        
        function sendPlayerMove() {
            socket.send(JSON.stringify({
                type: "move",
                player: {
                    id: player.id
                },
                x: player.x,
                y: player.y,
                vx: player.vx,
                vy: player.vy
            }));
        }
        
        function displayWinners(winners) {
            // Clear existing winners
            winnersContainer.innerHTML = '';
            
            // Set game result message
            const isPlayerWinner = winners.some(w => w.id === player.id);
            if (isPlayerWinner) {
                gameResult.textContent = 'Chúc mừng! Bạn là một trong những người thắng cuộc!';
                gameResult.classList.add('text-success');
                
                // Add confetti animation
                createConfetti();
            } else {
                gameResult.textContent = 'Tiếc quá! Bạn không phải là người thắng cuộc.';
                gameResult.classList.add('text-danger');
            }
            
            // Add winners to the list
            winners.forEach((winner, index) => {
                const winnerElement = document.createElement('div');
                winnerElement.className = 'flex items-center p-3 bg-gray-100 dark:bg-gray-700 rounded-lg';
                
                const rankElement = document.createElement('div');
                rankElement.className = 'text-2xl font-bold mr-3';
                rankElement.textContent = `#${index + 1}`;
                
                const colorElement = document.createElement('div');
                colorElement.className = 'w-10 h-10 rounded-full mr-3';
                colorElement.style.backgroundColor = winner.color;
                
                const infoElement = document.createElement('div');
                infoElement.className = 'flex-1';
                
                const nameElement = document.createElement('div');
                nameElement.className = 'font-semibold';
                nameElement.textContent = winner.name;
                if (winner.id === player.id) {
                    nameElement.textContent += ' (Bạn)';
                    nameElement.className += ' text-primary dark:text-dark-primary';
                }
                
                const flowerElement = document.createElement('div');
                flowerElement.className = 'text-sm';
                flowerElement.textContent = `Hoa: ${winner.flowers}`;
                
                infoElement.appendChild(nameElement);
                infoElement.appendChild(flowerElement);
                
                winnerElement.appendChild(rankElement);
                winnerElement.appendChild(colorElement);
                winnerElement.appendChild(infoElement);
                
                winnersContainer.appendChild(winnerElement);
            });
        }
        
        function createConfetti() {
            const colors = ['#FF6B9D', '#8A4FFF', '#06D6A0', '#FFD166', '#EF476F'];
            const totalConfetti = 100;
            
            for (let i = 0; i < totalConfetti; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.left = `${Math.random() * 100}%`;
                    confetti.style.top = '-10px';
                    confetti.style.width = `${Math.random() * 10 + 5}px`;
                    confetti.style.height = `${Math.random() * 10 + 5}px`;
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                    confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                    
                    document.body.appendChild(confetti);
                    
                    // Animate confetti falling
                    const animationDuration = Math.random() * 3 + 2;
                    const animationDelay = Math.random() * 5;
                    
                    confetti.animate([
                        { top: '-10px', left: `${parseFloat(confetti.style.left)}`, transform: `rotate(0deg)` },
                        { top: '100%', left: `${parseFloat(confetti.style.left) + (Math.random() * 20 - 10)}%`, transform: `rotate(${Math.random() * 720}deg)` }
                    ], {
                        duration: animationDuration * 1000,
                        delay: animationDelay * 1000,
                        easing: 'cubic-bezier(0.215, 0.610, 0.355, 1.000)',
                        fill: 'forwards'
                    });
                    
                    // Remove confetti after animation
                    setTimeout(() => {
                        confetti.remove();
                    }, (animationDuration + animationDelay) * 1000 + 500);
                }, Math.random() * 2000);
            }
        }
        
        function returnToLobby() {
            // Reset game state
            gameOver = false;
            gameStarted = false;
            player.health = 100;
            player.flowers = 0;
            player.alive = true;
            
            // Show lobby screen
            gameOverScreen.style.display = 'none';
            lobbyScreen.style.display = 'flex';
            waitingRoom.style.display = 'none';
            
            // Reset game result classes
            gameResult.classList.remove('text-success', 'text-danger');
            
            // Reconnect to server
            if (socket.readyState !== 1) {
                connectToServer();
            }
        }
        
        function generateId() {
            return 'id_' + Math.random().toString(36).substr(2, 9);
        }
        
        // Initialize the game
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
