<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hiếu Gà - Flower Battle Royale</title>
    <style>
        :root {
            --primary: #ff69b4;
            --secondary: #5D5CDE;
            --accent: #ff1493;
            --background: #fff5f8;
            --background-dark: #2a1a24;
            --text: #333;
            --text-dark: #f0f0f0;
            --shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            --gradient-pink: linear-gradient(135deg, #ff69b4, #ff1493);
            --gradient-purple: linear-gradient(135deg, #5D5CDE, #9370DB);
        }

        .dark {
            --primary: #ff69b4;
            --secondary: #7d7cee;
            --accent: #ff1493;
            --background: var(--background-dark);
            --text: var(--text-dark);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: 'Arial Rounded MT Bold', 'Avenir Next', 'Segoe UI', sans-serif;
            background-color: var(--background);
            color: var(--text);
            overflow: hidden;
            transition: background-color 0.3s;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        /* Logo Loading Screen */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: var(--background);
            z-index: 200;
        }

        #logo-animation {
            width: 200px;
            height: 200px;
            position: relative;
            margin-bottom: 30px;
        }

        .loading-bar-container {
            width: 250px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 30px;
            box-shadow: var(--shadow);
        }

        .loading-bar {
            height: 100%;
            width: 0%;
            background: var(--gradient-pink);
            border-radius: 10px;
            transition: width 0.1s;
        }

        /* Screen Styles */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: var(--background);
            z-index: 100;
            padding: 20px;
            text-align: center;
        }

        #menu-screen {
            background: var(--background);
        }

        #room-screen {
            display: none;
            background: var(--background);
        }

        #game-over-screen {
            display: none;
            background-color: rgba(93, 92, 222, 0.95);
            color: white;
        }

        #logo-container {
            position: relative;
            width: 180px;
            height: 180px;
            margin-bottom: 20px;
        }

        #logo {
            width: 100%;
            height: 100%;
        }

        .title {
            font-size: 32px;
            margin-bottom: 20px;
            color: var(--accent);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .subtitle {
            font-size: 18px;
            margin-bottom: 30px;
            color: var(--text);
            max-width: 85%;
        }

        /* Button Styles */
        .btn {
            background: var(--gradient-purple);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 16px 32px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            box-shadow: var(--shadow);
            transition: all 0.2s;
            min-width: 180px;
        }

        .btn:hover, .btn:active {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        .btn-pink {
            background: var(--gradient-pink);
        }

        .btn-disabled {
            background: #a9a9a9;
            cursor: not-allowed;
        }

        .btn-disabled:hover {
            transform: none;
            box-shadow: var(--shadow);
        }

        /* Input Styles */
        .input-group {
            margin: 10px 0;
            width: 100%;
            max-width: 300px;
        }

        .input {
            width: 100%;
            padding: 15px 20px;
            font-size: 16px;
            border-radius: 50px;
            border: 2px solid #ddd;
            background-color: white;
            transition: all 0.3s;
            text-align: center;
            color: var(--text);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(255, 20, 147, 0.3);
        }

        /* Room and Players */
        #room-info {
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--accent);
        }

        #player-list-container {
            width: 100%;
            max-width: 350px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 15px;
            margin: 20px 0;
            box-shadow: var(--shadow);
            max-height: 300px;
            overflow-y: auto;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            border-radius: 8px;
            margin: 5px 0;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .player-item.room-owner {
            background-color: rgba(93, 92, 222, 0.2);
        }

        .player-item.you {
            border-left: 4px solid var(--accent);
        }

        /* Game Canvas and HUD */
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 10px;
            box-shadow: var(--shadow);
            margin: 5px;
        }

        #scoreboard {
            position: absolute;
            top: 60px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 10px;
            box-shadow: var(--shadow);
            max-width: 200px;
            pointer-events: none;
            z-index: 10;
        }

        .scoreboard-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
        }

        .rank1 {
            color: gold;
            font-weight: bold;
        }

        .rank2 {
            color: silver;
            font-weight: bold;
        }

        .rank3 {
            color: #cd7f32; /* bronze */
            font-weight: bold;
        }
        
        #winner-list {
            margin: 20px 0;
            font-size: 24px;
            text-align: center;
        }
        
        .winner {
            margin: 10px 0;
            font-weight: bold;
        }
        
        .winner.rank1 {
            font-size: 32px;
            color: gold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .winner.rank2 {
            font-size: 28px;
            color: silver;
        }
        
        .winner.rank3 {
            font-size: 24px;
            color: #cd7f32;
        }
        
        #confetti-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 150;
        }
        
        #notification {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            color: var(--accent);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            box-shadow: var(--shadow);
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        /* Network Status */
        #network-status {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 15px;
            border-radius: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            color: var(--accent);
            font-weight: bold;
            font-size: 14px;
            z-index: 150;
            box-shadow: var(--shadow);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #network-status.connected {
            color: #2ecc71;
        }

        #network-status.connecting {
            color: #f39c12;
        }

        #network-status.disconnected {
            color: #e74c3c;
        }

        /* Error Message */
        #error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(231, 76, 60, 0.95);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: var(--shadow);
            max-width: 80%;
            z-index: 1000;
            text-align: center;
            display: none;
        }

        #error-message .btn {
            margin-top: 15px;
            font-size: 16px;
            padding: 10px 20px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" style="display: none;"></canvas>
        
        <div id="hud" style="display: none;">
            <div class="hud-panel" id="score-container">
                Hoa: <span id="score">0</span>
            </div>
            <div class="hud-panel" id="time-container">
                Thời gian: <span id="time">60</span>s
            </div>
        </div>
        
        <div id="scoreboard" style="display: none;"></div>
        <div id="notification"></div>
        <div id="network-status">Đang kết nối...</div>
        
        <!-- Loading Screen with Logo Animation -->
        <div id="loading-screen">
            <div id="logo-animation">
                <!-- Logo animation will be created with JavaScript -->
            </div>
            <div class="loading-bar-container">
                <div class="loading-bar" id="loading-progress"></div>
            </div>
        </div>
        
        <!-- Main Menu Screen -->
        <div id="menu-screen" class="screen" style="display: none;">
            <div id="logo-container">
                <!-- Logo will be inserted by JavaScript -->
            </div>
            <h1 class="title">Flower Battle Royale</h1>
            <p class="subtitle">Thu thập hoa trên bản đồ đang thu hẹp! Chơi cùng bạn bè trong trận chiến hoa 8/3!</p>
            
            <div class="input-group">
                <input type="text" id="player-name" class="input" placeholder="Nhập tên của bạn" maxlength="15">
            </div>
            
            <button id="create-room-btn" class="btn btn-pink">Tạo phòng mới</button>
            <button id="join-room-btn" class="btn">Vào phòng</button>
        </div>
        
        <!-- Room Screen -->
        <div id="room-screen" class="screen">
            <h1 class="title">Phòng đợi</h1>
            <div id="room-info">Mã phòng: <span id="room-code">----</span></div>
            
            <div id="player-list-container">
                <div id="player-list"></div>
            </div>
            
            <div id="room-message">Đang đợi người chơi... (0/8)</div>
            
            <button id="start-game-btn" class="btn btn-pink btn-disabled">Bắt đầu (0/8)</button>
            <button id="leave-room-btn" class="btn">Rời phòng</button>
        </div>
        
        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen">
            <h1 class="title">Game Kết Thúc!</h1>
            <div id="winner-list"></div>
            <button id="back-to-room-btn" class="btn">Trở về phòng đợi</button>
            <button id="back-to-menu-btn" class="btn">Về menu chính</button>
        </div>
        
        <!-- Error Message -->
        <div id="error-message">
            <h3>Lỗi kết nối</h3>
            <p id="error-text">Không thể kết nối đến máy chủ game.</p>
            <button id="error-ok-btn" class="btn">Đồng ý</button>
        </div>
    </div>
    
    <canvas id="confetti-canvas"></canvas>

    <script>
        // Kiểm tra chế độ tối
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // --------------------------
        // GAME CONFIGURATION
        // --------------------------
        
        const CONFIG = {
            // Thông số WebSocket
            SERVER_URL: "wss://botpirate-ten.vercel.app/flower-battle", // Thay thế bằng URL máy chủ thực tế của bạn
            RECONNECT_ATTEMPTS: 3,
            RECONNECT_DELAY: 2000,
            
            // Thông số Game
            GAME_DURATION: 60, // seconds
            MIN_PLAYERS: 2,    // Số người chơi tối thiểu để bắt đầu
            MAX_PLAYERS: 8,    // Số người chơi tối đa trong một phòng
            
            // Thông số Player
            PLAYER_SPEED: 5,
            PLAYER_RADIUS: 20,
            
            // Thông số Flower
            FLOWER_RADIUS: 10,
            MIN_FLOWERS: 30,   // Số lượng hoa tối thiểu trên bản đồ
            
            // Thông số Play Area
            INIT_AREA_RATIO: 0.45,  // Tỉ lệ giữa bán kính khu vực chơi và kích thước canvas
            SHRINK_RATE: 0.5,       // pixels/second
            MIN_AREA_RADIUS: 100,   // Bán kính tối thiểu
            
            // Thông số UI
            LOADING_DURATION: 5000, // 5 seconds
        };
        
        // --------------------------
        // GLOBAL VARIABLES
        // --------------------------
        
        let socket;
        let connectionAttempts = 0;
        
        // Game State
        const gameState = {
            status: 'menu', // 'menu', 'room', 'loading', 'playing', 'gameover'
            playerId: null,
            playerName: '',
            isRoomOwner: false,
            room: {
                id: null,
                code: null,
                players: [],
                playerCount: 0
            },
            game: {
                players: {},
                flowers: [],
                playArea: null,
                timeRemaining: 0,
                score: 0,
                lastUpdate: 0
            },
            input: {
                targetX: 0,
                targetY: 0,
                touch: false
            }
        };
        
        // Animation and UI state
        let animationFrame;
        let loadingProgress = 0;
        let notificationTimeout;
        let confetti = [];
        
        // Canvas và Context
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        const confettiCanvas = document.getElementById('confetti-canvas');
        const confettiCtx = confettiCanvas.getContext('2d');
        
        // --------------------------
        // UI ELEMENTS
        // --------------------------
        
        // Screens
        const loadingScreen = document.getElementById('loading-screen');
        const menuScreen = document.getElementById('menu-screen');
        const roomScreen = document.getElementById('room-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        
        // Menu UI
        const playerNameInput = document.getElementById('player-name');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        
        // Room UI
        const roomCodeDisplay = document.getElementById('room-code');
        const playerListContainer = document.getElementById('player-list');
        const roomMessageElement = document.getElementById('room-message');
        const startGameBtn = document.getElementById('start-game-btn');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        
        // Game UI
        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');
        const scoreboardElement = document.getElementById('scoreboard');
        const winnerListElement = document.getElementById('winner-list');
        const notificationElement = document.getElementById('notification');
        const networkStatusElement = document.getElementById('network-status');
        
        // Game Over UI
        const backToRoomBtn = document.getElementById('back-to-room-btn');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');
        
        // Error UI
        const errorMessageElement = document.getElementById('error-message');
        const errorTextElement = document.getElementById('error-text');
        const errorOkBtn = document.getElementById('error-ok-btn');
        
        // Logo Elements
        const logoAnimation = document.getElementById('logo-animation');
        const logoContainer = document.getElementById('logo-container');
        const loadingProgressBar = document.getElementById('loading-progress');
        
        // --------------------------
        // INITIALIZATION
        // --------------------------
        
        // Thiết lập kích thước canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
            
            // Resize PlayArea nếu đang trong game
            if (gameState.game.playArea) {
                gameState.game.playArea.x = canvas.width / 2;
                gameState.game.playArea.y = canvas.height / 2;
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // --------------------------
        // LOGO AND LOADING ANIMATION
        // --------------------------
        
        // Tạo logo Hiếu Gà animated
        function createAnimatedLogo() {
            // Create canvas for logo animation
            const logoCanvas = document.createElement('canvas');
            logoCanvas.width = 200;
            logoCanvas.height = 200;
            logoCanvas.id = 'logo-canvas';
            logoAnimation.appendChild(logoCanvas);
            
            // Create static logo for other screens
            createStaticLogo();
            
            // Start animation
            animateChickenLogo(logoCanvas);
        }
        
        // Tạo logo tĩnh cho các màn hình khác
        function createStaticLogo() {
            const logoImg = document.createElement('img');
            logoImg.id = 'logo';
            
            // Create static logo on canvas
            const staticCanvas = document.createElement('canvas');
            staticCanvas.width = 200;
            staticCanvas.height = 200;
            const ctx = staticCanvas.getContext('2d');
            
            // Draw circular background
            ctx.fillStyle = '#FFDE59';
            ctx.beginPath();
            ctx.arc(100, 100, 95, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw border
            ctx.strokeStyle = '#FF9A5A';
            ctx.lineWidth = 10;
            ctx.stroke();
            
            // Draw chicken body
            ctx.fillStyle = '#FF5A5A';
            ctx.beginPath();
            ctx.ellipse(100, 110, 50, 60, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw chicken head
            ctx.fillStyle = '#FF5A5A';
            ctx.beginPath();
            ctx.arc(100, 60, 30, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw chicken eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(85, 55, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(115, 55, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(85, 55, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(115, 55, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw chicken comb
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.moveTo(100, 30);
            ctx.lineTo(85, 45);
            ctx.lineTo(100, 40);
            ctx.lineTo(115, 45);
            ctx.closePath();
            ctx.fill();
            
            // Draw chicken beak
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.moveTo(100, 65);
            ctx.lineTo(90, 75);
            ctx.lineTo(110, 75);
            ctx.closePath();
            ctx.fill();
            
            // Draw chicken wings
            ctx.fillStyle = '#FF7A7A';
            ctx.beginPath();
            ctx.ellipse(60, 110, 15, 30, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(140, 110, 15, 30, -Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw chicken legs
            ctx.fillStyle = '#FFA500';
            ctx.fillRect(85, 165, 8, 20);
            ctx.fillRect(107, 165, 8, 20);
            
            // Draw chicken feet
            ctx.beginPath();
            ctx.moveTo(85, 185);
            ctx.lineTo(70, 190);
            ctx.lineTo(85, 185);
            ctx.lineTo(93, 190);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(115, 185);
            ctx.lineTo(130, 190);
            ctx.lineTo(115, 185);
            ctx.lineTo(107, 190);
            ctx.stroke();
            
            // Add text
            ctx.fillStyle = '#5D5CDE';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText('Hiếu Gà', 100, 240);
            
            logoImg.src = staticCanvas.toDataURL();
            
            // Clear and append to container
            logoContainer.innerHTML = '';
            logoContainer.appendChild(logoImg);
        }
        
        // Animate the chicken logo for loading screen
        function animateChickenLogo(canvas) {
            const ctx = canvas.getContext('2d');
            let frame = 0;
            let angle = 0;
            let eyeOffset = 0;
            let wingScale = 1;
            let scale = 0.9;
            let growing = true;
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Update animation values
                frame++;
                angle += 0.02;
                eyeOffset = Math.sin(frame * 0.1) * 2;
                wingScale = 1 + Math.sin(frame * 0.1) * 0.2;
                
                if (growing) {
                    scale += 0.003;
                    if (scale >= 1.1) growing = false;
                } else {
                    scale -= 0.003;
                    if (scale <= 0.9) growing = true;
                }
                
                // Save context for transformations
                ctx.save();
                ctx.translate(100, 100);
                ctx.scale(scale, scale);
                ctx.translate(-100, -100);
                
                // Draw circular background with glow
                const gradient = ctx.createRadialGradient(100, 100, 0, 100, 100, 100);
                gradient.addColorStop(0, '#FFDE59');
                gradient.addColorStop(0.8, '#FFDE59');
                gradient.addColorStop(1, '#FFC107');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(100, 100, 95, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw border with glow
                ctx.strokeStyle = '#FF9A5A';
                ctx.lineWidth = 10;
                ctx.stroke();
                
                // Draw chicken body
                ctx.fillStyle = '#FF5A5A';
                ctx.beginPath();
                ctx.ellipse(100, 110, 50, 60, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw chicken head
                ctx.fillStyle = '#FF5A5A';
                ctx.beginPath();
                ctx.arc(100, 60, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw animated chicken eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(85 + eyeOffset, 55, 8, 0, Math.PI * 2);
                ctx.arc(115 + eyeOffset, 55, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(85 + eyeOffset, 55, 4, 0, Math.PI * 2);
                ctx.arc(115 + eyeOffset, 55, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw chicken comb with wiggle
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(100, 30 + Math.sin(angle * 2) * 3);
                ctx.lineTo(85, 45);
                ctx.lineTo(100, 40 + Math.sin(angle * 2) * 2);
                ctx.lineTo(115, 45);
                ctx.closePath();
                ctx.fill();
                
                // Draw chicken beak
                ctx.fillStyle = '#FFA500';
                ctx.beginPath();
                ctx.moveTo(100, 65);
                ctx.lineTo(90, 75);
                ctx.lineTo(110, 75);
                ctx.closePath();
                ctx.fill();
                
                // Draw animated chicken wings
                ctx.fillStyle = '#FF7A7A';
                
                // Left wing
                ctx.save();
                ctx.translate(60, 110);
                ctx.rotate(Math.sin(angle) * 0.2);
                ctx.scale(wingScale, 1);
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 30, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // Right wing
                ctx.save();
                ctx.translate(140, 110);
                ctx.rotate(-Math.sin(angle) * 0.2);
                ctx.scale(wingScale, 1);
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 30, -Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // Draw chicken legs with movement
                const legOffset = Math.sin(angle) * 3;
                
                ctx.fillStyle = '#FFA500';
                ctx.fillRect(85, 165, 8, 20 + legOffset);
                ctx.fillRect(107, 165, 8, 20 - legOffset);
                
                // Draw chicken feet
                ctx.beginPath();
                ctx.moveTo(85, 185 + legOffset);
                ctx.lineTo(70, 190 + legOffset);
                ctx.lineTo(85, 185 + legOffset);
                ctx.lineTo(93, 190 + legOffset);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(115, 185 - legOffset);
                ctx.lineTo(130, 190 - legOffset);
                ctx.lineTo(115, 185 - legOffset);
                ctx.lineTo(107, 190 - legOffset);
                ctx.stroke();
                
                // Add pulsing text
                const textScale = 1 + Math.sin(angle * 2) * 0.1;
                ctx.save();
                ctx.translate(100, 240);
                ctx.scale(textScale, textScale);
                ctx.fillStyle = '#5D5CDE';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('Hiếu Gà', 0, 0);
                ctx.restore();
                
                ctx.restore();
                
                // Continue animation
                if (loadingProgress < 100) {
                    requestAnimationFrame(draw);
                }
            }
            
            draw();
        }
        
        // Handle loading screen progress
        function startLoading() {
            loadingProgress = 0;
            loadingProgressBar.style.width = '0%';
            
            // Start the loading animation
            createAnimatedLogo();
            
            // Simulate loading progress
            const totalFrames = 50; // Number of updates to reach 100%
            const frameTime = CONFIG.LOADING_DURATION / totalFrames;
            
            function updateProgress() {
                loadingProgress += 100 / totalFrames;
                if (loadingProgress > 100) loadingProgress = 100;
                
                loadingProgressBar.style.width = loadingProgress + '%';
                
                if (loadingProgress < 100) {
                    setTimeout(updateProgress, frameTime);
                } else {
                    // Loading complete
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        menuScreen.style.display = 'flex';
                        gameState.status = 'menu';
                    }, 200);
                }
            }
            
            updateProgress();
        }
        
        // --------------------------
        // NETWORK & WEBSOCKET
        // --------------------------
        
        // Initialize WebSocket connection
        function initializeWebSocket() {
            try {
                // Check if there's an existing connection
                if (socket && socket.readyState !== WebSocket.CLOSED) {
                    return;
                }
                
                setNetworkStatus('connecting');
                
                // Create WebSocket connection
                socket = new WebSocket(CONFIG.SERVER_URL);
                
                // Connection opened
                socket.addEventListener('open', (event) => {
                    console.log('Connected to server');
                    connectionAttempts = 0;
                    setNetworkStatus('connected');
                    
                    // Send auth data if we have player info
                    if (gameState.playerId && gameState.playerName) {
                        sendToServer({
                            type: 'auth',
                            playerId: gameState.playerId,
                            playerName: gameState.playerName
                        });
                    }
                });
                
                // Listen for messages
                socket.addEventListener('message', (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        handleServerMessage(message);
                    } catch (e) {
                        console.error('Error parsing message from server:', e);
                    }
                });
                
                // Connection closed
                socket.addEventListener('close', (event) => {
                    console.log('Disconnected from server', event.code, event.reason);
                    setNetworkStatus('disconnected');
                    
                    // Only try to reconnect if we're not intentionally closing
                    if (event.code !== 1000) {
                        handleDisconnect();
                    }
                });
                
                // Connection error
                socket.addEventListener('error', (error) => {
                    console.error('WebSocket error:', error);
                    setNetworkStatus('disconnected');
                });
                
            } catch (error) {
                console.error('Error initializing WebSocket:', error);
                showError('Không thể kết nối đến máy chủ game. Vui lòng thử lại sau.');
            }
        }
        
        // Handle network status display
        function setNetworkStatus(status) {
            networkStatusElement.className = status;
            
            switch (status) {
                case 'connecting':
                    networkStatusElement.textContent = 'Đang kết nối...';
                    networkStatusElement.style.opacity = '1';
                    break;
                case 'connected':
                    networkStatusElement.textContent = 'Đã kết nối';
                    // Fade out after 2 seconds
                    setTimeout(() => {
                        networkStatusElement.style.opacity = '0';
                    }, 2000);
                    break;
                case 'disconnected':
                    networkStatusElement.textContent = 'Mất kết nối!';
                    networkStatusElement.style.opacity = '1';
                    break;
            }
        }
        
        // Try to reconnect after disconnect
        function handleDisconnect() {
            if (connectionAttempts >= CONFIG.RECONNECT_ATTEMPTS) {
                showError('Mất kết nối với máy chủ. Vui lòng tải lại trang.');
                return;
            }
            
            connectionAttempts++;
            const delay = CONFIG.RECONNECT_DELAY * connectionAttempts;
            
            console.log(`Trying to reconnect in ${delay/1000} seconds...`);
            showNotification(`Đang thử kết nối lại (${connectionAttempts}/${CONFIG.RECONNECT_ATTEMPTS})...`);
            
            setTimeout(() => {
                initializeWebSocket();
            }, delay);
        }
        
        // Send message to server
        function sendToServer(message) {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                console.warn('Cannot send message, socket is not open');
                return false;
            }
            
            try {
                socket.send(JSON.stringify(message));
                return true;
            } catch (error) {
                console.error('Error sending message to server:', error);
                return false;
            }
        }
        
        // Handle messages from server
        function handleServerMessage(message) {
            console.log('Received message:', message.type);
            
            switch (message.type) {
                case 'player_id':
                    // Server assigned us a player ID
                    gameState.playerId = message.playerId;
                    break;
                    
                case 'room_created':
                    // Room created successfully
                    handleRoomCreated(message);
                    break;
                    
                case 'room_joined':
                    // Joined a room successfully
                    handleRoomJoined(message);
                    break;
                    
                case 'room_update':
                    // Room player list updated
                    handleRoomUpdate(message);
                    break;
                    
                case 'game_start':
                    // Game is starting
                    handleGameStart(message);
                    break;
                    
                case 'game_state':
                    // Game state update
                    handleGameState(message);
                    break;
                    
                case 'game_over':
                    // Game has ended
                    handleGameOver(message);
                    break;
                    
                case 'error':
                    // Error message from server
                    handleServerError(message);
                    break;
                    
                default:
                    console.warn('Unknown message type:', message.type);
            }
        }
        
        // --------------------------
        // SERVER MESSAGE HANDLERS
        // --------------------------
        
        // Handle room created message
        function handleRoomCreated(message) {
            gameState.room.id = message.roomId;
            gameState.room.code = message.roomCode;
            gameState.isRoomOwner = true;
            
            // Update UI
            roomCodeDisplay.textContent = message.roomCode;
            showScreen('room');
            showNotification('Phòng đã được tạo!');
        }
        
        // Handle room joined message
        function handleRoomJoined(message) {
            gameState.room.id = message.roomId;
            gameState.room.code = message.roomCode;
            gameState.isRoomOwner = message.isOwner;
            
            // Update UI
            roomCodeDisplay.textContent = message.roomCode;
            showScreen('room');
            showNotification('Đã vào phòng!');
        }
        
        // Handle room update message
        function handleRoomUpdate(message) {
            gameState.room.players = message.players;
            gameState.room.playerCount = message.players.length;
            
            // Update player list
            updatePlayerList();
            
            // Update room message
            updateRoomStatus();
        }
        
        // Handle game start message
        function handleGameStart(message) {
            // Initialize game state
            gameState.status = 'playing';
            gameState.game.timeRemaining = CONFIG.GAME_DURATION;
            gameState.game.score = 0;
            gameState.game.players = {};
            gameState.game.flowers = message.flowers || [];
            
            // Setup players
            message.players.forEach(player => {
                gameState.game.players[player.id] = player;
            });
            
            // Setup play area
            const areaData = message.playArea;
            gameState.game.playArea = new PlayArea(
                canvas.width / 2,
                canvas.height / 2,
                Math.min(canvas.width, canvas.height) * CONFIG.INIT_AREA_RATIO
            );
            
            // Show game UI
            showScreen('game');
            startGameLoop();
        }
        
        // Handle game state update
        function handleGameState(message) {
            // Update game state with server data
            gameState.game.timeRemaining = message.timeRemaining;
            
            // Update players
            Object.keys(message.players).forEach(playerId => {
                if (playerId in gameState.game.players) {
                    const serverPlayer = message.players[playerId];
                    const clientPlayer = gameState.game.players[playerId];
                    
                    // For all players except the local player, update position
                    if (playerId !== gameState.playerId) {
                        clientPlayer.x = serverPlayer.x;
                        clientPlayer.y = serverPlayer.y;
                    }
                    
                    // Update score for all players
                    clientPlayer.score = serverPlayer.score;
                } else {
                    // New player joined during game
                    gameState.game.players[playerId] = message.players[playerId];
                }
            });
            
            // Update flowers - only process server-side collected flowers
            if (message.flowers) {
                message.flowers.forEach(serverFlower => {
                    const clientFlower = gameState.game.flowers.find(f => f.id === serverFlower.id);
                    if (clientFlower) {
                        // If server says it's collected, update client
                        if (serverFlower.collected && !clientFlower.collected) {
                            clientFlower.collected = true;
                            clientFlower.collectedBy = serverFlower.collectedBy;
                        }
                    }
                });
            }
            
            // Add new flowers if server sent them
            if (message.newFlowers) {
                gameState.game.flowers = gameState.game.flowers.concat(message.newFlowers);
            }
            
            // Update play area
            if (message.playArea) {
                gameState.game.playArea.targetRadius = message.playArea.radius;
            }
            
            // Update UI
            updateGameUI();
        }
        
        // Handle game over message
        function handleGameOver(message) {
            gameState.status = 'gameover';
            
            // Sort players by score
            const sortedPlayers = Object.values(gameState.game.players)
                .sort((a, b) => b.score - a.score);
            
            // Create winner list HTML
            let html = '<h2>Top 3 người chơi</h2>';
            
            for (let i = 0; i < Math.min(3, sortedPlayers.length); i++) {
                const player = sortedPlayers[i];
                let rankClass = '';
                let emoji = '';
                
                if (i === 0) {
                    rankClass = 'rank1';
                    emoji = '👑';
                }
                else if (i === 1) {
                    rankClass = 'rank2';
                    emoji = '🥈';
                }
                else if (i === 2) {
                    rankClass = 'rank3';
                    emoji = '🥉';
                }
                
                const isYou = player.id === gameState.playerId ? ' (Bạn)' : '';
                
                html += `
                    <div class="winner ${rankClass}">
                        ${emoji} ${i + 1}. ${player.name}${isYou}: ${player.score} hoa 🌸
                    </div>
                `;
            }
            
            winnerListElement.innerHTML = html;
            
            // Show game over screen
            setTimeout(() => {
                showScreen('gameover');
                createConfetti();
            }, 2000);
        }
        
        // Handle server error message
        function handleServerError(message) {
            showError(message.message || 'Đã xảy ra lỗi.');
        }
        
        // --------------------------
        // GAME CLASSES
        // --------------------------
        
        // Lớp Player
        class Player {
            constructor(id, name, x, y, color, isHuman = false) {
                this.id = id;
                this.name = name;
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.radius = CONFIG.PLAYER_RADIUS;
                this.color = color;
                this.score = 0;
                this.isHuman = isHuman;
                this.speed = CONFIG.PLAYER_SPEED;
                this.isAlive = true;
                this.angle = 0;
                this.moveDirection = 0;
                this.animationFrame = 0;
                this.animationSpeed = 0.1;
                this.lastPositionSent = {x: 0, y: 0};
            }
            
            update(deltaTime) {
                if (!this.isAlive) return;
                
                // Cập nhật chuyển động cho người chơi
                if (this.isHuman) {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 5) {
                        const moveX = (dx / distance) * this.speed * (deltaTime / 16);
                        const moveY = (dy / distance) * this.speed * (deltaTime / 16);
                        this.x += moveX;
                        this.y += moveY;
                        this.moveDirection = Math.atan2(dy, dx);
                    }
                }
                
                // Kiểm tra xem người chơi có nằm trong khu vực chơi không
                const playArea = gameState.game.playArea;
                const distanceToCenter = Math.sqrt(
                    Math.pow(this.x - playArea.x, 2) + 
                    Math.pow(this.y - playArea.y, 2)
                );
                
                if (distanceToCenter > playArea.radius) {
                    // Di chuyển người chơi trở lại vào trong khu vực chơi
                    const angle = Math.atan2(this.y - playArea.y, this.x - playArea.x);
                    const newX = playArea.x + Math.cos(angle) * (playArea.radius - 5);
                    const newY = playArea.y + Math.sin(angle) * (playArea.radius - 5);
                    
                    this.x = newX;
                    this.y = newY;
                    
                    if (this.isHuman) {
                        this.targetX = this.x;
                        this.targetY = this.y;
                    }
                }
                
                // Cập nhật animation
                this.animationFrame += this.animationSpeed;
                this.angle = this.moveDirection;
                
                // Send position update to server (only for human player)
                if (this.isHuman && socket && socket.readyState === WebSocket.OPEN) {
                    // Only send update if position has changed significantly
                    const positionChanged = Math.abs(this.x - this.lastPositionSent.x) > 5 || 
                                          Math.abs(this.y - this.lastPositionSent.y) > 5;
                    
                    if (positionChanged) {
                        sendToServer({
                            type: 'player_move',
                            x: this.x,
                            y: this.y
                        });
                        
                        this.lastPositionSent.x = this.x;
                        this.lastPositionSent.y = this.y;
                    }
                }
            }
            
            draw(ctx) {
                if (!this.isAlive) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI / 2);
                
                // Body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius, this.radius * 1.2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Mắt
                const eyeX = Math.sin(this.animationFrame) * 2;
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-8 + eyeX, -10, 5, 0, Math.PI * 2);
                ctx.arc(8 + eyeX, -10, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-8 + eyeX, -10, 2.5, 0, Math.PI * 2);
                ctx.arc(8 + eyeX, -10, 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Cánh tay
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                
                // Cánh tay trái
                ctx.beginPath();
                ctx.arc(-this.radius - 2, 0, 8, 0, Math.PI * 2);
                ctx.stroke();
                
                // Cánh tay phải
                ctx.beginPath();
                ctx.arc(this.radius + 2, 0, 8, 0, Math.PI * 2);
                ctx.stroke();
                
                // Tên
                ctx.rotate(-this.angle - Math.PI / 2);
                const displayName = this.id === gameState.playerId ? this.name + ' (Bạn)' : this.name;
                ctx.fillStyle = this.id === gameState.playerId ? '#FF1493' : '#333';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(displayName, 0, -this.radius - 5);
                
                // Số hoa
                if (this.score > 0) {
                    ctx.font = '12px Arial';
                    ctx.fillText(`🌸 ${this.score}`, 0, -this.radius - 20);
                }
                
                ctx.restore();
            }
            
            collectFlowers(flowers) {
                if (!this.isHuman || !this.isAlive) return 0;
                
                let collected = 0;
                let idsCollected = [];
                
                for (const flower of flowers) {
                    if (!flower.collected) {
                        const dx = this.x - flower.x;
                        const dy = this.y - flower.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.radius + flower.radius) {
                            // Mark as collected locally immediately for responsive feel
                            flower.collected = true;
                            flower.collectedBy = this.id;
                            
                            // Track this for score update
                            idsCollected.push(flower.id);
                            collected++;
                        }
                    }
                }
                
                // Send collect message to server if any flowers were collected
                if (collected > 0) {
                    sendToServer({
                        type: 'collect_flowers',
                        flowerIds: idsCollected
                    });
                    
                    // Update local score immediately
                    this.score += collected;
                    gameState.game.score = this.score;
                    scoreElement.textContent = this.score;
                }
                
                return collected;
            }
        }
        
        // Lớp Flower
        class Flower {
            constructor(id, x, y, type) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = CONFIG.FLOWER_RADIUS;
                this.collected = false;
                this.collectedBy = null;
                this.angle = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() * 0.02) - 0.01;
                this.scale = 0.8 + Math.random() * 0.4;
            }
            
            update() {
                if (!this.collected) {
                    this.angle += this.rotationSpeed;
                }
            }
            
            draw(ctx) {
                if (this.collected) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.scale(this.scale, this.scale);
                
                const colors = [
                    '#FF69B4', // pink
                    '#FF1493', // deep pink
                    '#FFB6C1', // light pink
                    '#FFC0CB', // pink
                    '#FF77FF', // fuchsia
                ];
                
                const centerColors = [
                    '#FFFF00', // yellow
                    '#FFD700', // gold
                    '#FFA500', // orange
                ];
                
                const flowerColor = colors[this.type % colors.length];
                const centerColor = centerColors[this.type % centerColors.length];
                
                // Draw petals
                ctx.fillStyle = flowerColor;
                
                for (let i = 0; i < 5; i++) {
                    const angle = (i * Math.PI * 2) / 5;
                    ctx.beginPath();
                    ctx.ellipse(
                        Math.cos(angle) * 8,
                        Math.sin(angle) * 8,
                        7, 5, 
                        angle, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // Draw center
                ctx.fillStyle = centerColor;
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Lớp PlayArea
        class PlayArea {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.targetRadius = radius;
                this.shrinkRate = CONFIG.SHRINK_RATE; // đơn vị: pixel/giây
                this.minRadius = CONFIG.MIN_AREA_RADIUS;
                this.warningThreshold = 0.3; // khi còn 30% diện tích ban đầu
                this.criticalThreshold = 0.15; // khi còn 15% diện tích ban đầu
                this.lastPulse = 0;
                this.pulseInterval = 500;
                this.pulseAmount = 0;
            }
            
            update(deltaTime) {
                // Làm mượt việc giảm kích thước
                this.radius += (this.targetRadius - this.radius) * 0.05;
                
                // Hiệu ứng nhịp đập khi khu vực chơi nhỏ
                const now = Date.now();
                const ratio = this.radius / this.targetRadius;
                
                if (ratio < this.warningThreshold) {
                    if (now - this.lastPulse > this.pulseInterval) {
                        this.pulseAmount = ratio < this.criticalThreshold ? 10 : 5;
                        this.lastPulse = now;
                    }
                    
                    this.pulseAmount *= 0.9;
                }
            }
            
            draw(ctx) {
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius + this.pulseAmount
                );
                
                const ratio = this.radius / this.targetRadius;
                
                if (ratio < this.criticalThreshold) {
                    // Đỏ khi rất nhỏ
                    gradient.addColorStop(0, 'rgba(255, 100, 100, 0.1)');
                    gradient.addColorStop(0.7, 'rgba(255, 50, 50, 0.2)');
                    gradient.addColorStop(0.9, 'rgba(255, 0, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0.8)');
                } else if (ratio < this.warningThreshold) {
                    // Cam khi nhỏ
                    gradient.addColorStop(0, 'rgba(255, 200, 100, 0.1)');
                    gradient.addColorStop(0.7, 'rgba(255, 150, 50, 0.2)');
                    gradient.addColorStop(0.9, 'rgba(255, 100, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 100, 0, 0.8)');
                } else {
                    // Bình thường là màu hồng
                    gradient.addColorStop(0, 'rgba(255, 105, 180, 0.0)');
                    gradient.addColorStop(0.7, 'rgba(255, 105, 180, 0.1)');
                    gradient.addColorStop(0.9, 'rgba(255, 105, 180, 0.2)');
                    gradient.addColorStop(1, 'rgba(255, 105, 180, 0.5)');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + this.pulseAmount, 0, Math.PI * 2);
                ctx.fill();
                
                // Viền
                ctx.strokeStyle = ratio < this.criticalThreshold ? 'rgba(255, 0, 0, 0.8)' : 
                                 ratio < this.warningThreshold ? 'rgba(255, 100, 0, 0.8)' : 
                                 'rgba(255, 105, 180, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + this.pulseAmount, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Lớp Background
        class Background {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.elements = [];
                
                // Tạo các phần tử nền
                for (let i = 0; i < 50; i++) {
                    this.elements.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: 5 + Math.random() * 15,
                        type: Math.floor(Math.random() * 5),
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() * 0.01) - 0.005,
                        alpha: 0.1 + Math.random() * 0.2
                    });
                }
            }
            
            update() {
                for (const element of this.elements) {
                    element.rotation += element.rotationSpeed;
                }
            }
            
            draw(ctx) {
                const colors = [
                    '#FF69B4', // pink
                    '#FF1493', // deep pink
                    '#FFB6C1', // light pink
                    '#FFC0CB', // pink
                    '#FF77FF', // fuchsia
                ];
                
                for (const element of this.elements) {
                    ctx.save();
                    ctx.translate(element.x, element.y);
                    ctx.rotate(element.rotation);
                    ctx.globalAlpha = element.alpha;
                    
                    const color = colors[element.type % colors.length];
                    ctx.fillStyle = color;
                    
                    if (element.type === 0) {
                        // Hoa
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * Math.PI * 2) / 5;
                            ctx.beginPath();
                            ctx.ellipse(
                                Math.cos(angle) * element.size * 0.4,
                                Math.sin(angle) * element.size * 0.4,
                                element.size * 0.4, element.size * 0.3, 
                                angle, 0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                        
                        ctx.fillStyle = '#FFFF00';
                        ctx.beginPath();
                        ctx.arc(0, 0, element.size * 0.25, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (element.type === 1) {
                        // Trái tim
                        const size = element.size * 0.5;
                        ctx.beginPath();
                        ctx.moveTo(0, size);
                        ctx.bezierCurveTo(size, -size, 2*size, size, 0, 2*size);
                        ctx.bezierCurveTo(-2*size, size, -size, -size, 0, size);
                        ctx.fill();
                    } else if (element.type === 2) {
                        // Sao
                        const outerRadius = element.size * 0.5;
                        const innerRadius = element.size * 0.25;
                        
                        ctx.beginPath();
                        for (let i = 0; i < 10; i++) {
                            const angle = (i * Math.PI) / 5;
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                    } else if (element.type === 3) {
                        // Hình tròn
                        ctx.beginPath();
                        ctx.arc(0, 0, element.size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Cánh hoa
                        ctx.beginPath();
                        ctx.ellipse(0, 0, element.size * 0.3, element.size * 0.6, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            }
            
            resize(width, height) {
                this.width = width;
                this.height = height;
                
                // Điều chỉnh các phần tử nền cho phù hợp với kích thước mới
                for (const element of this.elements) {
                    if (element.x > width) element.x = Math.random() * width;
                    if (element.y > height) element.y = Math.random() * height;
                }
            }
        }
        
        // --------------------------
        // GAME LOOP AND RENDERING
        // --------------------------
        
        // Init background
        const background = new Background(canvas.width, canvas.height);
        
        // Start the game loop
        function startGameLoop() {
            // Show game UI
            canvas.style.display = 'block';
            document.getElementById('hud').style.display = 'flex';
            scoreboardElement.style.display = 'block';
            
            // Set initial timestamp
            gameState.game.lastUpdate = performance.now();
            
            // Start animation loop
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            animationFrame = requestAnimationFrame(gameLoop);
        }
        
        // Main game loop
        function gameLoop(timestamp) {
            // Calculate delta time
            const deltaTime = timestamp - gameState.game.lastUpdate;
            gameState.game.lastUpdate = timestamp;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw background
            background.update();
            background.draw(ctx);
            
            // Update and draw play area
            gameState.game.playArea.update(deltaTime);
            gameState.game.playArea.draw(ctx);
            
            // Update and draw flowers
            for (const flower of gameState.game.flowers) {
                flower.update();
                flower.draw(ctx);
            }
            
            // Get local player
            const localPlayer = gameState.game.players[gameState.playerId];
            
            // Update and draw players
            for (const playerId in gameState.game.players) {
                const player = gameState.game.players[playerId];
                
                // Only update the local player based on input
                if (playerId === gameState.playerId) {
                    player.update(deltaTime);
                    
                    // Check for flower collisions
                    const collectedCount = player.collectFlowers(gameState.game.flowers);
                    if (collectedCount > 0) {
                        if (collectedCount === 1) {
                            showNotification(`+1 Hoa! 🌸`);
                        } else {
                            showNotification(`+${collectedCount} Hoa! 🌸🌸`);
                        }
                    }
                }
                
                // Draw all players
                player.draw(ctx);
            }
            
            // Update confetti if any
            updateConfetti(deltaTime);
            drawConfetti();
            
            // Continue game loop if still playing
            if (gameState.status === 'playing') {
                animationFrame = requestAnimationFrame(gameLoop);
            }
        }
        
        // Update game UI
        function updateGameUI() {
            // Update time
            timeElement.textContent = Math.ceil(gameState.game.timeRemaining);
            
            // Update score
            scoreElement.textContent = gameState.game.score;
            
            // Update scoreboard
            updateScoreboard();
        }
        
        // Update scoreboard
        function updateScoreboard() {
            // Sort players by score
            const sortedPlayers = Object.values(gameState.game.players)
                .sort((a, b) => b.score - a.score);
            
            // Create scoreboard HTML
            let html = '<div class="scoreboard-title">Bảng xếp hạng</div>';
            
            for (let i = 0; i < sortedPlayers.length; i++) {
                const player = sortedPlayers[i];
                let rankClass = '';
                
                if (i === 0) rankClass = 'rank1';
                else if (i === 1) rankClass = 'rank2';
                else if (i === 2) rankClass = 'rank3';
                
                const isYou = player.id === gameState.playerId ? ' (Bạn)' : '';
                
                html += `
                    <div class="scoreboard-item ${rankClass} ${player.id === gameState.playerId ? 'human' : ''}">
                        <span>${i + 1}. ${player.name}${isYou}</span>
                        <span>${player.score}</span>
                    </div>
                `;
                
                // Only show top 5
                if (i >= 4) break;
            }
            
            scoreboardElement.innerHTML = html;
        }
        
        // --------------------------
        // UI FUNCTIONS
        // --------------------------
        
        // Show specific screen
        function showScreen(screen) {
            // Hide all screens
            loadingScreen.style.display = 'none';
            menuScreen.style.display = 'none';
            roomScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            canvas.style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            scoreboardElement.style.display = 'none';
            
            // Show requested screen
            switch (screen) {
                case 'loading':
                    loadingScreen.style.display = 'flex';
                    gameState.status = 'loading';
                    break;
                case 'menu':
                    menuScreen.style.display = 'flex';
                    gameState.status = 'menu';
                    break;
                case 'room':
                    roomScreen.style.display = 'flex';
                    gameState.status = 'room';
                    break;
                case 'game':
                    canvas.style.display = 'block';
                    document.getElementById('hud').style.display = 'flex';
                    scoreboardElement.style.display = 'block';
                    gameState.status = 'playing';
                    break;
                case 'gameover':
                    gameOverScreen.style.display = 'flex';
                    gameState.status = 'gameover';
                    break;
            }
        }
        
        // Update player list in room
        function updatePlayerList() {
            let html = '';
            const players = gameState.room.players;
            
            for (let i = 0; i < players.length; i++) {
                const player = players[i];
                const isOwner = player.isOwner;
                const isYou = player.id === gameState.playerId;
                const playerClasses = [
                    isOwner ? 'room-owner' : '',
                    isYou ? 'you' : ''
                ].filter(Boolean).join(' ');
                
                html += `
                    <div class="player-item ${playerClasses}">
                        <span>${player.name} ${isYou ? '(Bạn)' : ''} ${isOwner ? '👑' : ''}</span>
                        <span>Sẵn sàng</span>
                    </div>
                `;
            }
            
            playerListContainer.innerHTML = html;
        }
        
        // Update room status
        function updateRoomStatus() {
            const canStart = gameState.isRoomOwner && gameState.room.playerCount >= CONFIG.MIN_PLAYERS;
            
            // Update player count display
            roomMessageElement.textContent = `Đang đợi người chơi... (${gameState.room.playerCount}/${CONFIG.MAX_PLAYERS})`;
            
            // Update start button
            startGameBtn.textContent = `Bắt đầu (${gameState.room.playerCount}/${CONFIG.MIN_PLAYERS})`;
            
            if (canStart) {
                startGameBtn.classList.remove('btn-disabled');
            } else {
                startGameBtn.classList.add('btn-disabled');
            }
        }
        
        // Show notification
        function showNotification(message, duration = 2000) {
            // Clear previous timeout if exists
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
            }
            
            notificationElement.textContent = message;
            notificationElement.style.opacity = '1';
            
            notificationTimeout = setTimeout(() => {
                notificationElement.style.opacity = '0';
            }, duration);
        }
        
        // Show error message
        function showError(message) {
            errorTextElement.textContent = message;
            errorMessageElement.style.display = 'block';
        }
        
        // Create confetti effect
        function createConfetti() {
            const COLORS = [
                '#FF69B4', '#FF1493', '#FFB6C1', '#FFC0CB', '#FF77FF',
                '#FFFF00', '#FFD700', '#FFA500', '#5D5CDE', '#9370DB'
            ];
            
            // Create confetti particles
            confetti = [];
            for (let i = 0; i < 150; i++) {
                confetti.push({
                    x: Math.random() * confettiCanvas.width,
                    y: -20 - Math.random() * 100,
                    size: 5 + Math.random() * 10,
                    color: COLORS[Math.floor(Math.random() * COLORS.length)],
                    speed: 1 + Math.random() * 3,
                    angle: Math.random() * Math.PI * 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    oscillationSpeed: 1 + Math.random() * 2,
                    oscillationDistance: 40 + Math.random() * 40,
                    waviness: Math.random() * 5,
                    type: Math.floor(Math.random() * 3) // 0: rectangle, 1: circle, 2: heart
                });
            }
            
            // Start the confetti animation
            if (!animationFrame) {
                animationFrame = requestAnimationFrame(function(timestamp) {
                    updateConfetti(16.67); // ~60fps
                    drawConfetti();
                    
                    if (confetti.length > 0) {
                        animationFrame = requestAnimationFrame(arguments.callee);
                    } else {
                        animationFrame = null;
                    }
                });
            }
        }
        
        // Update confetti animation
        function updateConfetti(deltaTime) {
            for (let i = confetti.length - 1; i >= 0; i--) {
                const c = confetti[i];
                
                c.y += c.speed * deltaTime * 0.06;
                c.x += Math.sin(c.angle) * c.oscillationDistance * Math.sin(c.y * c.waviness * 0.01) * 0.1;
                c.rotation += c.rotationSpeed * deltaTime * 0.06;
                
                // Remove confetti that has fallen off screen
                if (c.y > confettiCanvas.height + 20) {
                    confetti.splice(i, 1);
                }
            }
        }
        
        // Draw confetti
        function drawConfetti() {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            
            for (const c of confetti) {
                confettiCtx.save();
                confettiCtx.translate(c.x, c.y);
                confettiCtx.rotate(c.rotation);
                
                confettiCtx.fillStyle = c.color;
                
                if (c.type === 0) {
                    // Rectangle
                    confettiCtx.fillRect(-c.size / 2, -c.size / 2, c.size, c.size);
                } else if (c.type === 1) {
                    // Circle
                    confettiCtx.beginPath();
                    confettiCtx.arc(0, 0, c.size / 2, 0, Math.PI * 2);
                    confettiCtx.fill();
                } else {
                    // Heart
                    const size = c.size * 0.4;
                    confettiCtx.beginPath();
                    confettiCtx.moveTo(0, size);
                    confettiCtx.bezierCurveTo(size, -size, 2*size, size, 0, 2*size);
                    confettiCtx.bezierCurveTo(-2*size, size, -size, -size, 0, size);
                    confettiCtx.fill();
                }
                
                confettiCtx.restore();
            }
        }
        
        // --------------------------
        // EVENT HANDLERS
        // --------------------------
        
        // Touch and Mouse input for game
        function setupGameInput() {
            // Touch events
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            
            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            if (gameState.status !== 'playing') return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            updatePlayerTarget(x, y);
            gameState.input.touch = true;
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (gameState.status !== 'playing' || !gameState.input.touch) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            updatePlayerTarget(x, y);
        }
        
        function handleMouseDown(e) {
            if (gameState.status !== 'playing') return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            updatePlayerTarget(x, y);
            gameState.input.touch = true;
        }
        
        function handleMouseMove(e) {
            if (gameState.status !== 'playing' || !gameState.input.touch || e.buttons !== 1) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            updatePlayerTarget(x, y);
        }
        
        function updatePlayerTarget(x, y) {
            // Update the target position for the local player
            const player = gameState.game.players[gameState.playerId];
            if (player) {
                player.targetX = x;
                player.targetY = y;
                gameState.input.targetX = x;
                gameState.input.targetY = y;
            }
        }
        
        // --------------------------
        // NETWORKING ACTIONS
        // --------------------------
        
        // Create room action
        function createRoom() {
            const playerName = playerNameInput.value.trim();
            
            if (!playerName) {
                showError('Vui lòng nhập tên của bạn.');
                return;
            }
            
            gameState.playerName = playerName;
            
            sendToServer({
                type: 'create_room',
                playerName: playerName
            });
        }
        
        // Join room action
        function joinRoom() {
            const playerName = playerNameInput.value.trim();
            
            if (!playerName) {
                showError('Vui lòng nhập tên của bạn.');
                return;
            }
            
            // Prompt for room code
            const roomCode = prompt('Nhập mã phòng:');
            if (!roomCode) return;
            
            gameState.playerName = playerName;
            
            sendToServer({
                type: 'join_room',
                playerName: playerName,
                roomCode: roomCode
            });
        }
        
        // Start game action
        function startGame() {
            if (!gameState.isRoomOwner || gameState.room.playerCount < CONFIG.MIN_PLAYERS) {
                return;
            }
            
            sendToServer({
                type: 'start_game',
                roomId: gameState.room.id
            });
        }
        
        // Leave room action
        function leaveRoom() {
            sendToServer({
                type: 'leave_room',
                roomId: gameState.room.id
            });
            
            // Reset room state
            gameState.room.id = null;
            gameState.room.code = null;
            gameState.room.players = [];
            gameState.room.playerCount = 0;
            gameState.isRoomOwner = false;
            
            // Go back to menu
            showScreen('menu');
        }
        
        // --------------------------
        // BUTTON EVENT LISTENERS
        // --------------------------
        
        // Menu buttons
        createRoomBtn.addEventListener('click', createRoom);
        joinRoomBtn.addEventListener('click', joinRoom);
        
        // Room buttons
        startGameBtn.addEventListener('click', startGame);
        leaveRoomBtn.addEventListener('click', leaveRoom);
        
        // Game over buttons
        backToRoomBtn.addEventListener('click', () => {
            showScreen('room');
        });
        
        backToMenuBtn.addEventListener('click', () => {
            if (gameState.room.id) {
                leaveRoom();
            } else {
                showScreen('menu');
            }
        });
        
        // Error buttons
        errorOkBtn.addEventListener('click', () => {
            errorMessageElement.style.display = 'none';
        });
        
        // --------------------------
        // INITIALIZATION
        // --------------------------
        
        // Setup game input
        setupGameInput();
        
        // Start loading screen
        startLoading();
        
        // Initialize WebSocket (commented out for testing)
        // Uncomment and update CONFIG.SERVER_URL when you have a real server
        // initializeWebSocket();
        
        // For testing only - simulate websocket server
        function simulateWebSocketServer() {
            // We'll create a fake implementation for testing
            console.log('Using WebSocket simulation mode');
            
            // Simulate connection after a delay
            setTimeout(() => {
                setNetworkStatus('connected');
                
                // Simulate player_id message
                handleServerMessage({
                    type: 'player_id',
                    playerId: 'player_' + Math.floor(Math.random() * 10000)
                });
            }, 1000);
            
            // Override sendToServer to simulate server responses
            window.realSendToServer = sendToServer;
            sendToServer = function(message) {
                console.log('Sending to simulated server:', message);
                
                // Simulate server response based on message type
                setTimeout(() => {
                    switch (message.type) {
                        case 'create_room':
                            handleServerMessage({
                                type: 'room_created',
                                roomId: 'room_' + Math.floor(Math.random() * 10000),
                                roomCode: Math.floor(1000 + Math.random() * 9000).toString(),
                                isOwner: true
                            });
                            
                            // Simulate room_update after create
                            setTimeout(() => {
                                handleServerMessage({
                                    type: 'room_update',
                                    players: [
                                        {
                                            id: gameState.playerId,
                                            name: message.playerName,
                                            isOwner: true
                                        }
                                    ]
                                });
                            }, 300);
                            break;
                            
                        case 'join_room':
                            if (Math.random() > 0.2) {
                                // Success
                                handleServerMessage({
                                    type: 'room_joined',
                                    roomId: 'room_' + Math.floor(Math.random() * 10000),
                                    roomCode: message.roomCode,
                                    isOwner: false
                                });
                                
                                // Simulate room_update after join
                                setTimeout(() => {
                                    // Create 1-6 simulated players plus the joining player
                                    const numOtherPlayers = Math.floor(Math.random() * 6);
                                    const players = [];
                                    
                                    // Add owner
                                    players.push({
                                        id: 'player_owner',
                                        name: 'Chủ phòng',
                                        isOwner: true
                                    });
                                    
                                    // Add other players
                                    for (let i = 0; i < numOtherPlayers; i++) {
                                        players.push({
                                            id: 'player_' + i,
                                            name: 'Người chơi ' + (i + 1),
                                            isOwner: false
                                        });
                                    }
                                    
                                    // Add joining player
                                    players.push({
                                        id: gameState.playerId,
                                        name: message.playerName,
                                        isOwner: false
                                    });
                                    
                                    handleServerMessage({
                                        type: 'room_update',
                                        players: players
                                    });
                                }, 300);
                            } else {
                                // Failure
                                handleServerMessage({
                                    type: 'error',
                                    message: 'Phòng không tồn tại hoặc đã đầy.'
                                });
                            }
                            break;
                            
                        case 'start_game':
                            // Generate random players
                            const playersMap = {};
                            const colors = [
                                '#FF6B8B', // human player
                                '#64B5F6',
                                '#81C784',
                                '#FFD54F',
                                '#BA68C8',
                                '#4FC3F7',
                                '#AED581'
                            ];
                            
                            // Add all room players to the game
                            gameState.room.players.forEach((player, index) => {
                                const centerX = canvas.width / 2;
                                const centerY = canvas.height / 2;
                                const radius = Math.min(canvas.width, canvas.height) * 0.25;
                                
                                const angle = (index * Math.PI * 2) / gameState.room.players.length;
                                const x = centerX + Math.cos(angle) * radius * 0.5;
                                const y = centerY + Math.sin(angle) * radius * 0.5;
                                
                                playersMap[player.id] = {
                                    id: player.id,
                                    name: player.name,
                                    x: x,
                                    y: y,
                                    color: colors[index % colors.length],
                                    score: 0
                                };
                            });
                            
                            // Generate random flowers
                            const flowers = [];
                            const centerX = canvas.width / 2;
                            const centerY = canvas.height / 2;
                            const playAreaRadius = Math.min(canvas.width, canvas.height) * CONFIG.INIT_AREA_RATIO * 0.9;
                            
                            for (let i = 0; i < 30; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = Math.random() * playAreaRadius;
                                const x = centerX + Math.cos(angle) * distance;
                                const y = centerY + Math.sin(angle) * distance;
                                
                                flowers.push({
                                    id: 'flower_' + i,
                                    x: x,
                                    y: y,
                                    type: Math.floor(Math.random() * 5),
                                    collected: false
                                });
                            }
                            
                            handleServerMessage({
                                type: 'game_start',
                                players: Object.values(playersMap),
                                flowers: flowers,
                                playArea: {
                                    radius: playAreaRadius
                                }
                            });
                            
                            // Simulate game state updates
                            let gameTimeRemaining = CONFIG.GAME_DURATION;
                            const gameInterval = setInterval(() => {
                                if (gameState.status !== 'playing') {
                                    clearInterval(gameInterval);
                                    return;
                                }
                                
                                gameTimeRemaining -= 1;
                                
                                // Update bot player positions
                                Object.values(playersMap).forEach(player => {
                                    if (player.id !== gameState.playerId) {
                                        // Random movement
                                        player.x += (Math.random() - 0.5) * 10;
                                        player.y += (Math.random() - 0.5) * 10;
                                        
                                        // Collect flowers randomly
                                        if (Math.random() < 0.1) {
                                            // Find uncollected flower
                                            const uncollectedFlowers = flowers.filter(f => !f.collected);
                                            if (uncollectedFlowers.length > 0) {
                                                const flowerIndex = Math.floor(Math.random() * uncollectedFlowers.length);
                                                const flower = uncollectedFlowers[flowerIndex];
                                                flower.collected = true;
                                                flower.collectedBy = player.id;
                                                
                                                // Increment score
                                                player.score += 1;
                                            }
                                        }
                                    }
                                });
                                
                                // Shrink play area
                                playAreaRadius = Math.max(
                                    CONFIG.MIN_AREA_RADIUS,
                                    playAreaRadius - CONFIG.SHRINK_RATE
                                );
                                
                                // Add new flowers occasionally
                                if (Math.random() < 0.3) {
                                    const uncollectedCount = flowers.filter(f => !f.collected).length;
                                    
                                    if (uncollectedCount < CONFIG.MIN_FLOWERS) {
                                        const newFlowers = [];
                                        const flowerCount = Math.floor(Math.random() * 5) + 3;
                                        
                                        for (let i = 0; i < flowerCount; i++) {
                                            const angle = Math.random() * Math.PI * 2;
                                            const distance = Math.random() * playAreaRadius * 0.8;
                                            const x = centerX + Math.cos(angle) * distance;
                                            const y = centerY + Math.sin(angle) * distance;
                                            
                                            const newFlower = {
                                                id: 'flower_new_' + Date.now() + '_' + i,
                                                x: x,
                                                y: y,
                                                type: Math.floor(Math.random() * 5),
                                                collected: false
                                            };
                                            
                                            newFlowers.push(newFlower);
                                            flowers.push(newFlower);
                                        }
                                        
                                        // Update with new flowers
                                        handleServerMessage({
                                            type: 'game_state',
                                            players: playersMap,
                                            timeRemaining: gameTimeRemaining,
                                            newFlowers: newFlowers,
                                            playArea: {
                                                radius: playAreaRadius
                                            }
                                        });
                                    }
                                } else {
                                    // Regular update
                                    handleServerMessage({
                                        type: 'game_state',
                                        players: playersMap,
                                        timeRemaining: gameTimeRemaining,
                                        playArea: {
                                            radius: playAreaRadius
                                        }
                                    });
                                }
                                
                                // End game when time runs out
                                if (gameTimeRemaining <= 0) {
                                    clearInterval(gameInterval);
                                    
                                    handleServerMessage({
                                        type: 'game_over',
                                        players: playersMap
                                    });
                                }
                            }, 1000);
                            break;
                            
                        case 'leave_room':
                            // No response needed
                            break;
                            
                        case 'player_move':
                            // Update local player in our simulated state
                            if (gameState.game.players && gameState.game.players[gameState.playerId]) {
                                gameState.game.players[gameState.playerId].x = message.x;
                                gameState.game.players[gameState.playerId].y = message.y;
                            }
                            break;
                            
                        case 'collect_flowers':
                            // Already handled by client for responsive feel
                            break;
                    }
                }, 200);
                
                return true;
            };
        }
        
        // Use simulation mode for testing
        simulateWebSocketServer();
    </script>
</body>
</html>
