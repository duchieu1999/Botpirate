<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artillery Battle</title>
    <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4.6.1/dist/socket.io.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#4CAF50',
                        danger: '#F44336',
                        warning: '#FFC107',
                        info: '#2196F3',
                    },
                    animation: {
                        'bounce-slow': 'bounce 3s infinite',
                        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'float': 'float 3s ease-in-out infinite',
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        }
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Nunito', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #uiCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        .game-ui {
            position: absolute;
            z-index: 3;
            pointer-events: auto;
        }
        
        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            user-select: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        
        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .angle-btn {
            background: linear-gradient(135deg, #ff7e5f, #feb47b);
        }
        
        .power-btn {
            background: linear-gradient(135deg, #6a11cb, #2575fc);
        }
        
        .fire-btn {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #FF416C, #FF4B2B);
            font-size: 20px;
            font-weight: bold;
        }
        
        .inventory-btn {
            background: linear-gradient(135deg, #F09819, #EDDE5D);
        }
        
        .weapon-indicator {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 20px;
            font-weight: bold;
            z-index: 3;
        }
        
        .player-info {
            position: absolute;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 12px;
            font-weight: bold;
            z-index: 3;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .health-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF416C, #FF4B2B);
            transition: width 0.3s ease;
        }
        
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #6441A5, #2a0845);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .loader {
            width: 80px;
            height: 80px;
            border: 8px solid rgba(255, 255, 255, 0.1);
            border-left-color: #5D5CDE;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #menuScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://i.imgur.com/MWvA6l5.jpg') no-repeat center center;
            background-size: cover;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 900;
        }
        
        #menuScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: -1;
        }
        
        .menu-container {
            max-width: 500px;
            width: 90%;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .menu-title {
            font-size: 2.5rem;
            font-weight: bold;
            color: white;
            text-align: center;
            margin-bottom: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .input-group {
            margin-bottom: 1rem;
        }
        
        .input-label {
            display: block;
            margin-bottom: 0.5rem;
            color: white;
            font-weight: bold;
        }
        
        .input-field {
            width: 100%;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            color: white;
            outline: none;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        
        .input-field::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .input-field:focus {
            border-color: #5D5CDE;
            box-shadow: 0 0 0 3px rgba(93, 92, 222, 0.3);
        }
        
        .menu-btn {
            display: block;
            width: 100%;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            font-weight: bold;
            text-align: center;
            background: #5D5CDE;
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: transform 0.3s, background 0.3s;
            margin-top: 1rem;
        }
        
        .menu-btn:hover {
            background: #4a49b8;
        }
        
        .menu-btn:active {
            transform: scale(0.98);
        }
        
        .menu-divider {
            display: flex;
            align-items: center;
            margin: 1.5rem 0;
            color: white;
        }
        
        .menu-divider::before,
        .menu-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255, 255, 255, 0.3);
        }
        
        .menu-divider span {
            padding: 0 1rem;
        }
        
        #roomScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #43cea2, #185a9d);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 800;
        }
        
        .rooms-container {
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .room-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            margin-bottom: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            color: white;
            transition: background 0.3s;
        }
        
        .room-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .room-name {
            font-weight: bold;
            margin-right: 1rem;
        }
        
        .room-info {
            font-size: 0.875rem;
            opacity: 0.8;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            font-weight: bold;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .toast.show {
            opacity: 1;
        }
        
        .character-selection {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
            overflow-x: auto;
            padding: 0.5rem;
        }
        
        .character-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            transition: transform 0.2s, background 0.2s;
        }
        
        .character-option.selected {
            background: rgba(93, 92, 222, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 0 2px #5D5CDE;
        }
        
        .character-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .character-preview {
            width: 60px;
            height: 60px;
            margin-bottom: 0.5rem;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
        }
        
        .character-name {
            color: white;
            font-size: 0.875rem;
            text-align: center;
        }
        
        #mapSelectionContainer {
            margin-top: 1.5rem;
            width: 100%;
        }
        
        .map-selection {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 0.5rem;
            overflow-x: auto;
            padding: 0.5rem;
        }
        
        .map-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            transition: transform 0.2s, background 0.2s;
        }
        
        .map-option.selected {
            background: rgba(93, 92, 222, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 0 2px #5D5CDE;
        }
        
        .map-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .map-preview {
            width: 100px;
            height: 60px;
            margin-bottom: 0.5rem;
            border-radius: 0.25rem;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .map-name {
            color: white;
            font-size: 0.875rem;
            text-align: center;
        }
        
        .waiting-room {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2b5876, #4e4376);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 750;
        }
        
        .waiting-container {
            max-width: 500px;
            width: 90%;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        
        .players-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .player-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            min-width: 100px;
        }
        
        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
            margin-bottom: 0.5rem;
        }
        
        .player-name {
            color: white;
            font-weight: bold;
            margin-bottom: 0.25rem;
        }
        
        .player-status {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .waiting-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            margin-bottom: 1rem;
        }
        
        .waiting-subtitle {
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 2rem;
        }
        
        .pulse-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            background-color: #5D5CDE;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
        }
        
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }
        
        .game-over-container {
            max-width: 500px;
            width: 90%;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        
        .game-over-title {
            font-size: 2.5rem;
            font-weight: bold;
            color: white;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .win-animation {
            animation: scale-up 0.5s cubic-bezier(0.165, 0.84, 0.44, 1);
        }
        
        @keyframes scale-up {
            from {
                transform: scale(0);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .winner-info {
            margin-bottom: 2rem;
            color: white;
        }
        
        .inventory-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            padding: 1rem;
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
            transform: translateY(100%);
            transition: transform 0.3s;
            z-index: 10;
        }
        
        .inventory-panel.show {
            transform: translateY(0);
        }
        
        .inventory-title {
            color: white;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }
        
        .inventory-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            color: white;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .inventory-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .inventory-item.selected {
            background: rgba(93, 92, 222, 0.5);
            box-shadow: 0 0 0 2px #5D5CDE;
        }
        
        .inventory-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
        }
        
        .inventory-name {
            font-size: 0.75rem;
            text-align: center;
        }
        
        .close-inventory {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            font-size: 1.25rem;
        }
        
        .turn-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 20px;
            font-weight: bold;
            z-index: 3;
            display: flex;
            align-items: center;
        }
        
        .turn-icon {
            width: 24px;
            height: 24px;
            margin-right: 8px;
            border-radius: 50%;
            background: #5D5CDE;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .wind-indicator {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 20px;
            font-weight: bold;
            z-index: 3;
            display: flex;
            align-items: center;
        }
        
        .wind-arrow {
            width: 24px;
            height: 24px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chat-container {
            position: absolute;
            bottom: 80px;
            left: 10px;
            width: 300px;
            max-width: calc(100% - 20px);
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            z-index: 5;
            transform: translateX(-320px);
            transition: transform 0.3s;
        }
        
        .chat-container.show {
            transform: translateX(0);
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .chat-input-container {
            display: flex;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
        }
        
        .chat-input {
            flex: 1;
            padding: 8px 12px;
            border-radius: 20px;
            border: none;
            outline: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        .chat-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .chat-send {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #5D5CDE;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
            cursor: pointer;
        }
        
        .chat-message {
            margin-bottom: 8px;
            font-size: 14px;
            color: white;
        }
        
        .chat-name {
            font-weight: bold;
            margin-right: 6px;
        }
        
        .system-message {
            color: #FFC107;
            font-style: italic;
        }
        
        .chat-toggle {
            position: absolute;
            bottom: 80px;
            left: 10px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 4;
            font-size: 20px;
        }
        
        @media (max-width: 640px) {
            .inventory-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        .dark {
            color-scheme: dark;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div class="loader"></div>
        <p class="mt-4 text-white font-bold">Loading Artillery Battle...</p>
    </div>
    
    <div id="menuScreen">
        <div class="menu-container">
            <h1 class="menu-title">Artillery Battle</h1>
            <div class="input-group">
                <label for="playerName" class="input-label">Your Name</label>
                <input type="text" id="playerName" class="input-field" placeholder="Enter your name" maxlength="15">
            </div>
            
            <div class="character-selection">
                <!-- Character options will be generated here -->
            </div>
            
            <button id="createRoomBtn" class="menu-btn">Create Room</button>
            
            <div class="menu-divider">
                <span>or</span>
            </div>
            
            <button id="joinRoomBtn" class="menu-btn">Join Room</button>
        </div>
    </div>
    
    <div id="roomScreen" style="display: none;">
        <div class="rooms-container">
            <h1 class="menu-title">Available Rooms</h1>
            <div id="roomsList">
                <!-- Room list items will be generated here -->
            </div>
            <div class="mt-4 flex justify-between">
                <button id="refreshRoomsBtn" class="menu-btn w-auto px-4">Refresh</button>
                <button id="backToMenuBtn" class="menu-btn w-auto px-4">Back</button>
            </div>
        </div>
    </div>
    
    <div id="waitingRoom" class="waiting-room" style="display: none;">
        <div class="waiting-container">
            <h2 class="waiting-title">Waiting for Players</h2>
            <div id="roomCode" class="mb-4 bg-white/10 py-2 px-4 rounded-md inline-block">
                Room Code: <span id="roomCodeValue" class="font-bold">XXXX</span>
            </div>
            <p class="waiting-subtitle"><span class="pulse-dot"></span> Waiting for players to join...</p>
            
            <div class="players-list" id="waitingPlayersList">
                <!-- Players will be added here -->
            </div>
            
            <div id="mapSelectionContainer" style="display: none;">
                <h3 class="text-white font-bold mb-2">Select Map</h3>
                <div class="map-selection" id="mapSelectionList">
                    <!-- Map options will be generated here -->
                </div>
            </div>
            
            <div class="flex justify-between mt-4">
                <button id="leaveRoomBtn" class="menu-btn w-auto px-4">Leave Room</button>
                <button id="startGameBtn" class="menu-btn w-auto px-4" style="display: none;">Start Game</button>
            </div>
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    <canvas id="uiCanvas"></canvas>
    
    <div id="gameUI" style="display: none;">
        <div class="turn-indicator">
            <div class="turn-icon">ðŸŽ¯</div>
            <span id="turnText">Your Turn</span>
        </div>
        
        <div class="wind-indicator">
            <div class="wind-arrow" id="windArrow">â†’</div>
            <span id="windText">Wind: 0 m/s</span>
        </div>
        
        <div class="weapon-indicator">
            <span id="weaponName">Basic Cannon</span>
        </div>
        
        <div class="game-ui" style="bottom: 20px; left: 20px;">
            <div class="control-btn angle-btn" id="angleDownBtn">-</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; left: 80px;">
            <div class="control-btn angle-btn" id="angleUpBtn">+</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; right: 80px;">
            <div class="control-btn power-btn" id="powerDownBtn">-</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; right: 20px;">
            <div class="control-btn power-btn" id="powerUpBtn">+</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; left: 50%; transform: translateX(-50%);">
            <div class="control-btn fire-btn" id="fireBtn">FIRE!</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; left: 160px;">
            <div class="control-btn inventory-btn" id="inventoryBtn">ðŸŽ’</div>
        </div>
        
        <div class="game-ui chat-toggle" id="chatToggleBtn">ðŸ’¬</div>
        
        <div class="chat-container" id="chatContainer">
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" placeholder="Type a message...">
                <div class="chat-send" id="chatSendBtn">âž¤</div>
            </div>
        </div>
        
        <div class="inventory-panel" id="inventoryPanel">
            <div class="inventory-title">Weapons & Items</div>
            <div class="inventory-grid" id="inventoryGrid">
                <!-- Inventory items will be generated here -->
            </div>
            <div class="close-inventory" id="closeInventoryBtn">Ã—</div>
        </div>
    </div>
    
    <div id="gameOverScreen" class="game-over" style="display: none;">
        <div class="game-over-container win-animation">
            <h1 class="game-over-title" id="gameOverTitle">Victory!</h1>
            <div class="winner-info" id="winnerInfo">
                Player Name won the match!
            </div>
            <button id="playAgainBtn" class="menu-btn">Play Again</button>
            <button id="exitGameBtn" class="menu-btn mt-4">Exit to Menu</button>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>
    
    <script>
        // Constants
        const GRAVITY = 0.2;
        const MAX_POWER = 100;
        const TERRAIN_SEGMENTS = 100;
        const CLOUD_COUNT = 8;
        const TICK_RATE = 16; // ~60fps
        
        // Game state
        let gameState = {
            screen: 'loading',
            playerId: null,
            playerName: '',
            roomId: null,
            isRoomOwner: false,
            isMyTurn: false,
            players: [],
            terrain: [],
            platforms: [],
            projectiles: [],
            explosions: [],
            particles: [],
            powerups: [],
            angle: 45,
            power: 50,
            wind: 0,
            gravity: GRAVITY,
            selectedWeapon: 'basic',
            inventory: {
                basic: { type: 'weapon', name: 'Basic Cannon', icon: 'ðŸ’£', ammo: -1 },
                missile: { type: 'weapon', name: 'Missile', icon: 'ðŸš€', ammo: 5 },
                cluster: { type: 'weapon', name: 'Cluster Bomb', icon: 'ðŸ§¨', ammo: 3 },
                sniper: { type: 'weapon', name: 'Sniper Shot', icon: 'ðŸŽ¯', ammo: 3 },
                grenade: { type: 'weapon', name: 'Grenade', icon: 'ðŸ’¥', ammo: 3 },
                healthpack: { type: 'item', name: 'Health Pack', icon: 'â¤ï¸', ammo: 2 },
                shield: { type: 'item', name: 'Shield', icon: 'ðŸ›¡ï¸', ammo: 1 }
            },
            clouds: [],
            camera: { x: 0, y: 0, targetX: 0, targetY: 0, scale: 1 },
            map: null,
            mapOptions: [
                { id: 'hills', name: 'Rolling Hills', preview: createMapPreview('hills') },
                { id: 'mountains', name: 'Mountain Range', preview: createMapPreview('mountains') },
                { id: 'canyon', name: 'Deep Canyon', preview: createMapPreview('canyon') },
                { id: 'islands', name: 'Floating Islands', preview: createMapPreview('islands') }
            ],
            characters: [
                { id: 'tank', name: 'Tank', icon: 'ðŸ”«', color: '#FF5722', maxHealth: 120, damageMultiplier: 1 },
                { id: 'scout', name: 'Scout', icon: 'ðŸƒ', color: '#4CAF50', maxHealth: 80, damageMultiplier: 1.2 },
                { id: 'heavy', name: 'Heavy', icon: 'ðŸ›¡ï¸', color: '#2196F3', maxHealth: 150, damageMultiplier: 0.9 },
                { id: 'medic', name: 'Medic', icon: 'â¤ï¸', color: '#F44336', maxHealth: 100, damageMultiplier: 0.8 }
            ],
            selectedCharacter: 'tank',
            dragStart: null,
            lastFrameTime: 0,
            chatVisible: false
        };
        
        // Socket connection
        let socket = null;
        
        // DOM elements
        const loadingScreen = document.getElementById('loadingScreen');
        const menuScreen = document.getElementById('menuScreen');
        const roomScreen = document.getElementById('roomScreen');
        const waitingRoom = document.getElementById('waitingRoom');
        const gameCanvas = document.getElementById('gameCanvas');
        const uiCanvas = document.getElementById('uiCanvas');
        const gameUI = document.getElementById('gameUI');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const toast = document.getElementById('toast');
        
        // Game canvases and contexts
        const ctx = gameCanvas.getContext('2d');
        const uiCtx = uiCanvas.getContext('2d');
        
        // Set canvas resolution based on device pixel ratio
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = gameCanvas.getBoundingClientRect();
            
            gameCanvas.width = rect.width * dpr;
            gameCanvas.height = rect.height * dpr;
            uiCanvas.width = rect.width * dpr;
            uiCanvas.height = rect.height * dpr;
            
            ctx.scale(dpr, dpr);
            uiCtx.scale(dpr, dpr);
            
            gameCanvas.style.width = `${rect.width}px`;
            gameCanvas.style.height = `${rect.height}px`;
            uiCanvas.style.width = `${rect.width}px`;
            uiCanvas.style.height = `${rect.height}px`;
        }
        
        // Initialize the game
        function init() {
            setupCanvas();
            
            // Dark mode detection
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                if (event.matches) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });
            
            // Create character selection UI
            const characterSelection = document.querySelector('.character-selection');
            gameState.characters.forEach(char => {
                const charElement = document.createElement('div');
                charElement.className = `character-option ${char.id === gameState.selectedCharacter ? 'selected' : ''}`;
                charElement.dataset.characterId = char.id;
                charElement.innerHTML = `
                    <div class="character-preview" style="background-color: ${char.color}">${char.icon}</div>
                    <div class="character-name">${char.name}</div>
                `;
                charElement.addEventListener('click', () => {
                    document.querySelectorAll('.character-option').forEach(el => {
                        el.classList.remove('selected');
                    });
                    charElement.classList.add('selected');
                    gameState.selectedCharacter = char.id;
                });
                characterSelection.appendChild(charElement);
            });
            
            // Generate map selection UI
            const mapSelectionList = document.getElementById('mapSelectionList');
            gameState.mapOptions.forEach((map, index) => {
                const mapElement = document.createElement('div');
                mapElement.className = `map-option ${index === 0 ? 'selected' : ''}`;
                mapElement.dataset.mapId = map.id;
                mapElement.innerHTML = `
                    <div class="map-preview">${map.preview}</div>
                    <div class="map-name">${map.name}</div>
                `;
                mapElement.addEventListener('click', () => {
                    document.querySelectorAll('.map-option').forEach(el => {
                        el.classList.remove('selected');
                    });
                    mapElement.classList.add('selected');
                    gameState.map = map.id;
                });
                mapSelectionList.appendChild(mapElement);
            });
            
            // Generate inventory items
            populateInventory();
            
            // Set up event listeners for UI elements
            setupEventListeners();
            
            // Setup websocket connection
            setupSocketConnection();
            
            // Start game loop
            requestAnimationFrame(gameLoop);
            
            // Simulate loading complete
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                gameState.screen = 'menu';
            }, 1500);
        }
        
        // Generate map previews
        function createMapPreview(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 60;
            const ctx = canvas.getContext('2d');
            
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 40);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F7FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 100, 60);
            
            // Draw terrain based on map type
            ctx.fillStyle = '#8B4513';
            
            switch(type) {
                case 'hills':
                    ctx.beginPath();
                    ctx.moveTo(0, 40);
                    ctx.bezierCurveTo(20, 35, 40, 45, 60, 40);
                    ctx.bezierCurveTo(80, 35, 90, 45, 100, 40);
                    ctx.lineTo(100, 60);
                    ctx.lineTo(0, 60);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'mountains':
                    ctx.beginPath();
                    ctx.moveTo(0, 50);
                    ctx.lineTo(20, 30);
                    ctx.lineTo(40, 45);
                    ctx.lineTo(60, 25);
                    ctx.lineTo(80, 40);
                    ctx.lineTo(100, 20);
                    ctx.lineTo(100, 60);
                    ctx.lineTo(0, 60);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'canyon':
                    ctx.beginPath();
                    ctx.moveTo(0, 35);
                    ctx.lineTo(30, 35);
                    ctx.lineTo(40, 55);
                    ctx.lineTo(60, 55);
                    ctx.lineTo(70, 35);
                    ctx.lineTo(100, 35);
                    ctx.lineTo(100, 60);
                    ctx.lineTo(0, 60);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'islands':
                    // First island
                    ctx.beginPath();
                    ctx.arc(30, 45, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Second island
                    ctx.beginPath();
                    ctx.arc(70, 40, 12, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
            
            return canvas.outerHTML;
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Menu buttons
            document.getElementById('createRoomBtn').addEventListener('click', createRoom);
            document.getElementById('joinRoomBtn').addEventListener('click', () => {
                gameState.screen = 'roomList';
                menuScreen.style.display = 'none';
                roomScreen.style.display = 'flex';
                fetchRooms();
            });
            
            // Room list buttons
            document.getElementById('refreshRoomsBtn').addEventListener('click', fetchRooms);
            document.getElementById('backToMenuBtn').addEventListener('click', () => {
                gameState.screen = 'menu';
                roomScreen.style.display = 'none';
                menuScreen.style.display = 'flex';
            });
            
            // Waiting room buttons
            document.getElementById('leaveRoomBtn').addEventListener('click', leaveRoom);
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            
            // Game over buttons
            document.getElementById('playAgainBtn').addEventListener('click', () => {
                gameOverScreen.style.display = 'none';
                waitingRoom.style.display = 'flex';
                gameUI.style.display = 'none';
                gameState.screen = 'waiting';
                socket.emit('ready-for-new-game');
            });
            
            document.getElementById('exitGameBtn').addEventListener('click', () => {
                gameOverScreen.style.display = 'none';
                menuScreen.style.display = 'flex';
                gameUI.style.display = 'none';
                gameState.screen = 'menu';
                socket.emit('leave-room');
                gameState.roomId = null;
                gameState.isRoomOwner = false;
            });
            
            // Game controls
            document.getElementById('angleUpBtn').addEventListener('click', () => {
                if (gameState.isMyTurn) {
                    gameState.angle = Math.min(90, gameState.angle + 5);
                    updateAngleUI();
                }
            });
            
            document.getElementById('angleDownBtn').addEventListener('click', () => {
                if (gameState.isMyTurn) {
                    gameState.angle = Math.max(0, gameState.angle - 5);
                    updateAngleUI();
                }
            });
            
            document.getElementById('powerUpBtn').addEventListener('click', () => {
                if (gameState.isMyTurn) {
                    gameState.power = Math.min(MAX_POWER, gameState.power + 5);
                    updatePowerUI();
                }
            });
            
            document.getElementById('powerDownBtn').addEventListener('click', () => {
                if (gameState.isMyTurn) {
                    gameState.power = Math.max(10, gameState.power - 5);
                    updatePowerUI();
                }
            });
            
            document.getElementById('fireBtn').addEventListener('click', () => {
                if (gameState.isMyTurn) {
                    fireWeapon();
                }
            });
            
            document.getElementById('inventoryBtn').addEventListener('click', toggleInventory);
            document.getElementById('closeInventoryBtn').addEventListener('click', toggleInventory);
            
            // Chat controls
            document.getElementById('chatToggleBtn').addEventListener('click', toggleChat);
            document.getElementById('chatSendBtn').addEventListener('click', sendChatMessage);
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage();
                }
            });
            
            // Map dragging
            gameCanvas.addEventListener('mousedown', handleDragStart);
            gameCanvas.addEventListener('touchstart', handleDragStart, { passive: false });
            
            gameCanvas.addEventListener('mousemove', handleDragMove);
            gameCanvas.addEventListener('touchmove', handleDragMove, { passive: false });
            
            gameCanvas.addEventListener('mouseup', handleDragEnd);
            gameCanvas.addEventListener('touchend', handleDragEnd);
            
            // Resize handler
            window.addEventListener('resize', () => {
                setupCanvas();
            });
        }
        
        // Socket connection setup with real Socket.io
        function setupSocketConnection() {
            // Connect to Socket.io server
            // When deploying to railway.app, the URL will be automatically adjusted
            const serverUrl = window.location.hostname === 'localhost' 
                ? 'http://localhost:3000' 
                : window.location.origin;
            
            socket = io(serverUrl);
            
            // Set up socket event handlers
            setupSocketEvents();
        }
        
        // Create a new game room
        function createRoom() {
            const playerNameInput = document.getElementById('playerName');
            const playerName = playerNameInput.value.trim() || `Player${Math.floor(Math.random() * 1000)}`;
            
            if (playerName.length < 3) {
                showToast('Name must be at least 3 characters');
                return;
            }
            
            gameState.playerName = playerName;
            
            socket.emit('create-room', { 
                playerName: playerName,
                character: gameState.selectedCharacter
            }, (response) => {
                if (response.success) {
                    gameState.roomId = response.roomId;
                    gameState.isRoomOwner = true;
                    gameState.players = response.players;
                    
                    document.getElementById('roomCodeValue').textContent = response.roomId;
                    document.getElementById('startGameBtn').style.display = 'block';
                    document.getElementById('mapSelectionContainer').style.display = 'block';
                    
                    updateWaitingRoomPlayers();
                    
                    menuScreen.style.display = 'none';
                    waitingRoom.style.display = 'flex';
                    gameState.screen = 'waiting';
                } else {
                    showToast('Failed to create room: ' + response.message);
                }
            });
        }
        
        // Fetch available rooms
        function fetchRooms() {
            document.getElementById('roomsList').innerHTML = '<p class="text-center text-white">Loading rooms...</p>';
            
            socket.emit('get-rooms', (response) => {
                if (response.success) {
                    const roomsList = document.getElementById('roomsList');
                    
                    if (response.rooms.length === 0) {
                        roomsList.innerHTML = '<p class="text-center text-white">No rooms available. Create a new one!</p>';
                        return;
                    }
                    
                    roomsList.innerHTML = '';
                    
                    response.rooms.forEach(room => {
                        const roomItem = document.createElement('div');
                        roomItem.className = 'room-item';
                        roomItem.innerHTML = `
                            <div>
                                <div class="room-name">${room.name || 'Game Room'}</div>
                                <div class="room-info">Players: ${room.players}/${room.maxPlayers}</div>
                            </div>
                            <button class="menu-btn w-auto px-4 py-2 text-sm">Join</button>
                        `;
                        
                        roomItem.querySelector('button').addEventListener('click', () => {
                            joinRoom(room.id);
                        });
                        
                        roomsList.appendChild(roomItem);
                    });
                } else {
                    showToast('Failed to fetch rooms: ' + response.message);
                }
            });
        }
        
        // Join an existing room
        function joinRoom(roomId) {
            const playerNameInput = document.getElementById('playerName');
            const playerName = playerNameInput.value.trim() || `Player${Math.floor(Math.random() * 1000)}`;
            
            if (playerName.length < 3) {
                showToast('Name must be at least 3 characters');
                return;
            }
            
            gameState.playerName = playerName;
            
            socket.emit('join-room', {
                roomId: roomId,
                playerName: playerName,
                character: gameState.selectedCharacter
            }, (response) => {
                if (response.success) {
                    gameState.roomId = response.roomId;
                    gameState.isRoomOwner = false;
                    gameState.players = response.players;
                    
                    document.getElementById('roomCodeValue').textContent = response.roomId;
                    document.getElementById('startGameBtn').style.display = 'none';
                    document.getElementById('mapSelectionContainer').style.display = 'none';
                    
                    updateWaitingRoomPlayers();
                    
                    roomScreen.style.display = 'none';
                    waitingRoom.style.display = 'flex';
                    gameState.screen = 'waiting';
                } else {
                    showToast('Failed to join room: ' + response.message);
                }
            });
        }
        
        // Leave the current room
        function leaveRoom() {
            socket.emit('leave-room');
            
            waitingRoom.style.display = 'none';
            menuScreen.style.display = 'flex';
            gameState.screen = 'menu';
            gameState.roomId = null;
            gameState.isRoomOwner = false;
        }
        
        // Start the game
        function startGame() {
            if (!gameState.isRoomOwner) return;
            
            // Get selected map
            const selectedMapEl = document.querySelector('.map-option.selected');
            if (selectedMapEl) {
                gameState.map = selectedMapEl.dataset.mapId;
            }
            
            socket.emit('start-game', { mapId: gameState.map });
        }
        
        // Update player list in waiting room
        function updateWaitingRoomPlayers() {
            const waitingPlayersList = document.getElementById('waitingPlayersList');
            waitingPlayersList.innerHTML = '';
            
            gameState.players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                
                const character = gameState.characters.find(c => c.id === player.character);
                
                playerCard.innerHTML = `
                    <div class="player-avatar" style="background-color: ${character ? character.color : '#666'}">${character ? character.icon : 'ðŸ‘¤'}</div>
                    <div class="player-name">${player.name}</div>
                    <div class="player-status">${player.isOwner ? 'Room Owner' : 'Player'}</div>
                `;
                
                waitingPlayersList.appendChild(playerCard);
            });
        }
        
        // Update the angle UI
        function updateAngleUI() {
            // This would update a visible angle indicator
            // For this demo, we'll just redraw
        }
        
        // Update the power UI
        function updatePowerUI() {
            // This would update a visible power indicator
            // For this demo, we'll just redraw
        }
        
        // Fire the current weapon
        function fireWeapon() {
            if (!gameState.isMyTurn) return;
            
            const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
            if (!currentPlayer) return;
            
            const weapon = gameState.inventory[gameState.selectedWeapon];
            
            // Check if we have ammo for this weapon
            if (weapon.ammo === 0) {
                showToast('Out of ammo for this weapon!');
                return;
            }
            
            // Decrease ammo if limited
            if (weapon.ammo > 0) {
                weapon.ammo--;
            }
            
            // Disable controls during firing
            gameState.isMyTurn = false;
            document.getElementById('turnText').textContent = 'Firing...';
            
            // Calculate initial velocity based on angle and power
            const angleRad = gameState.angle * Math.PI / 180;
            const power = gameState.power / 100 * 20; // Scale power to a reasonable velocity
            
            const velocityX = Math.cos(angleRad) * power * (currentPlayer.facingLeft ? -1 : 1);
            const velocityY = -Math.sin(angleRad) * power;
            
            // Create projectile
            const projectile = {
                id: 'proj-' + Date.now(),
                x: currentPlayer.x + (currentPlayer.facingLeft ? -20 : 20),
                y: currentPlayer.y - 10,
                velocityX: velocityX,
                velocityY: velocityY,
                type: gameState.selectedWeapon,
                ownerId: currentPlayer.id,
                gravity: gameState.gravity,
                wind: gameState.wind,
                trailParticles: []
            };
            
            gameState.projectiles.push(projectile);
            
            // Set camera to follow projectile
            gameState.camera.targetX = projectile.x;
            gameState.camera.targetY = projectile.y;
            
            // Tell server about the fired projectile
            socket.emit('fire', {
                projectile: projectile,
                weapon: gameState.selectedWeapon
            });
        }
        
        // Toggle inventory panel
        function toggleInventory() {
            const inventoryPanel = document.getElementById('inventoryPanel');
            inventoryPanel.classList.toggle('show');
        }
        
        // Populate inventory with weapons and items
        function populateInventory() {
            const inventoryGrid = document.getElementById('inventoryGrid');
            inventoryGrid.innerHTML = '';
            
            Object.entries(gameState.inventory).forEach(([id, item]) => {
                const inventoryItem = document.createElement('div');
                inventoryItem.className = `inventory-item ${id === gameState.selectedWeapon ? 'selected' : ''}`;
                inventoryItem.dataset.itemId = id;
                
                // Display infinite ammo as âˆž
                const ammoDisplay = item.ammo < 0 ? 'âˆž' : item.ammo;
                
                inventoryItem.innerHTML = `
                    <div class="inventory-icon">${item.icon}</div>
                    <div class="inventory-name">${item.name}</div>
                    <div class="text-xs">${ammoDisplay}</div>
                `;
                
                inventoryItem.addEventListener('click', () => {
                    if (item.type === 'weapon' && gameState.isMyTurn) {
                        document.querySelectorAll('.inventory-item').forEach(el => {
                            el.classList.remove('selected');
                        });
                        inventoryItem.classList.add('selected');
                        gameState.selectedWeapon = id;
                        document.getElementById('weaponName').textContent = item.name;
                        inventoryPanel.classList.remove('show');
                    } else if (item.type === 'item' && gameState.isMyTurn && item.ammo > 0) {
                        useItem(id);
                        inventoryPanel.classList.remove('show');
                    }
                });
                
                inventoryGrid.appendChild(inventoryItem);
            });
        }
        
        // Use an inventory item
        function useItem(itemId) {
            const item = gameState.inventory[itemId];
            if (!item || item.type !== 'item' || item.ammo <= 0) return;
            
            const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
            if (!currentPlayer) return;
            
            switch (itemId) {
                case 'healthpack':
                    // Heal player
                    currentPlayer.health = Math.min(currentPlayer.maxHealth, currentPlayer.health + 30);
                    
                    // Add healing effect
                    gameState.particles.push(...createHealingEffect(currentPlayer.x, currentPlayer.y));
                    
                    showToast('+30 Health');
                    break;
                case 'shield':
                    // Add shield effect
                    currentPlayer.effects.push({
                        type: 'shield',
                        duration: 2, // lasts for 2 turns
                        value: 0.5 // reduces damage by 50%
                    });
                    
                    // Add shield visual effect
                    gameState.particles.push(...createShieldEffect(currentPlayer.x, currentPlayer.y));
                    
                    showToast('Shield Activated');
                    break;
            }
            
            // Decrease item count
            item.ammo--;
            
            // Update inventory
            populateInventory();
            
            // End turn after using item
            socket.emit('turn-complete');
        }
        
        // Create healing effect particles
        function createHealingEffect(x, y) {
            const particles = [];
            
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x + (Math.random() * 40 - 20),
                    y: y + (Math.random() * 40 - 20),
                    velocityX: (Math.random() - 0.5) * 2,
                    velocityY: -Math.random() * 3,
                    size: 5 + Math.random() * 10,
                    color: '#4CAF50',
                    opacity: 1,
                    life: 30 + Math.random() * 30
                });
            }
            
            return particles;
        }
        
        // Create shield effect particles
        function createShieldEffect(x, y) {
            const particles = [];
            
            for (let i = 0; i < 30; i++) {
                const angle = i / 30 * Math.PI * 2;
                const distance = 40;
                
                particles.push({
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    velocityX: Math.cos(angle) * 0.5,
                    velocityY: Math.sin(angle) * 0.5,
                    size: 8,
                    color: '#64B5F6',
                    opacity: 1,
                    life: 60 + Math.random() * 20
                });
            }
            
            return particles;
        }
        
        // Toggle chat visibility
        function toggleChat() {
            const chatContainer = document.getElementById('chatContainer');
            chatContainer.classList.toggle('show');
            gameState.chatVisible = chatContainer.classList.contains('show');
            
            if (gameState.chatVisible) {
                document.getElementById('chatInput').focus();
            }
        }
        
        // Send a chat message
        function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (message) {
                socket.emit('chat-message', {
                    sender: gameState.playerName,
                    message: message
                });
                
                chatInput.value = '';
            }
        }
        
        // Add a message to the chat
        function addChatMessage(sender, message, isSystem = false) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            
            messageElement.className = isSystem ? 'chat-message system-message' : 'chat-message';
            
            if (isSystem) {
                messageElement.textContent = message;
            } else {
                messageElement.innerHTML = `<span class="chat-name">${sender}:</span> ${message}`;
            }
            
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // Handle drag start (for map movement)
        function handleDragStart(e) {
            e.preventDefault();
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            if (clientX && clientY) {
                gameState.dragStart = {
                    x: clientX,
                    y: clientY,
                    cameraX: gameState.camera.x,
                    cameraY: gameState.camera.y
                };
            }
        }
        
        // Handle drag move
        function handleDragMove(e) {
            e.preventDefault();
            
            if (!gameState.dragStart) return;
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            if (clientX && clientY) {
                const dx = (clientX - gameState.dragStart.x) * 2;
                const dy = (clientY - gameState.dragStart.y) * 2;
                
                gameState.camera.x = gameState.dragStart.cameraX - dx;
                gameState.camera.y = gameState.dragStart.cameraY - dy;
                
                // Update target position as well to prevent snap-back
                gameState.camera.targetX = gameState.camera.x;
                gameState.camera.targetY = gameState.camera.y;
            }
        }
        
        // Handle drag end
        function handleDragEnd() {
            gameState.dragStart = null;
        }
        
        // Show a toast notification
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }
        
        // Main game loop
        function gameLoop(timestamp) {
            const deltaTime = timestamp - gameState.lastFrameTime;
            gameState.lastFrameTime = timestamp;
            
            // Update game state
            update(deltaTime);
            
            // Render game
            render();
            
            // Request next frame
            requestAnimationFrame(gameLoop);
        }
        
        // Update game state
        function update(deltaTime) {
            if (gameState.screen !== 'game') return;
            
            // Update camera position smoothly
            const cameraSpeed = 0.1;
            gameState.camera.x += (gameState.camera.targetX - gameState.camera.x) * cameraSpeed;
            gameState.camera.y += (gameState.camera.targetY - gameState.camera.y) * cameraSpeed;
            
            // Update projectiles
            updateProjectiles();
            
            // Update explosions
            updateExplosions();
            
            // Update particles
            updateParticles(deltaTime);
            
            // Update clouds
            updateClouds();
        }
        
        // Update projectiles
        function updateProjectiles() {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                
                // Apply gravity
                proj.velocityY += proj.gravity;
                
                // Apply wind
                proj.velocityX += parseFloat(proj.wind) * 0.01;
                
                // Update position
                proj.x += proj.velocityX;
                proj.y += proj.velocityY;
                
                // Add trail particles
                if (Math.random() > 0.5) {
                    gameState.particles.push({
                        x: proj.x,
                        y: proj.y,
                        velocityX: (Math.random() - 0.5) * 2,
                        velocityY: (Math.random() - 0.5) * 2,
                        size: 4,
                        color: getProjectileColor(proj.type),
                        opacity: 0.7,
                        life: 20
                    });
                }
                
                // Check for collisions with terrain or platforms
                if (checkProjectileCollision(proj)) {
                    createExplosion(proj);
                    gameState.projectiles.splice(i, 1);
                    continue;
                }
                
                // Check if out of bounds
                if (proj.x < 0 || proj.x > 3000 || proj.y > 1500) {
                    gameState.projectiles.splice(i, 1);
                    
                    // End turn if all projectiles are gone
                    if (gameState.projectiles.length === 0) {
                        endTurn();
                    }
                }
                
                // Update camera to follow projectile
                gameState.camera.targetX = proj.x;
                gameState.camera.targetY = proj.y;
            }
        }
        
        // Check if a projectile collides with terrain or players
        function checkProjectileCollision(projectile) {
            // Check collision with terrain
            const terrainCollision = checkTerrainCollision(projectile.x, projectile.y);
            if (terrainCollision) return true;
            
            // Check collision with platforms
            for (const platform of gameState.platforms) {
                if (projectile.x >= platform.x && 
                    projectile.x <= platform.x + platform.width &&
                    projectile.y >= platform.y && 
                    projectile.y <= platform.y + platform.height) {
                    return true;
                }
            }
            
            // Check collision with players
            for (const player of gameState.players) {
                if (!player.alive || player.id === projectile.ownerId) continue;
                
                const dx = projectile.x - player.x;
                const dy = projectile.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 30) { // Player hitbox radius
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if a point collides with terrain
        function checkTerrainCollision(x, y) {
            if (!gameState.terrain || gameState.terrain.length === 0) return false;
            
            const terrain = gameState.terrain;
            const segmentWidth = 3000 / TERRAIN_SEGMENTS;
            
            // Find the two terrain points surrounding x
            const index = Math.floor(x / segmentWidth);
            
            if (index < 0 || index >= terrain.length - 1) return false;
            
            const p1 = terrain[index];
            const p2 = terrain[index + 1];
            
            // Interpolate height at x
            const t = (x - p1.x) / (p2.x - p1.x);
            const terrainHeight = p1.y + t * (p2.y - p1.y);
            
            // Check if y is below terrain height
            return y >= terrainHeight;
        }
        
        // Get color for projectile trail based on weapon type
        function getProjectileColor(type) {
            switch (type) {
                case 'basic': return '#FF9800';
                case 'missile': return '#F44336';
                case 'cluster': return '#9C27B0';
                case 'sniper': return '#4CAF50';
                case 'grenade': return '#FFEB3B';
                default: return '#FFFFFF';
            }
        }
        
        // Create an explosion
        function createExplosion(projectile) {
            let radius, damage, particleCount;
            
            // Different explosion properties based on weapon type
            switch (projectile.type) {
                case 'basic':
                    radius = 80;
                    damage = 25;
                    particleCount = 30;
                    break;
                case 'missile':
                    radius = 100;
                    damage = 35;
                    particleCount = 40;
                    break;
                case 'cluster':
                    radius = 60;
                    damage = 15;
                    particleCount = 25;
                    
                    // Create additional smaller explosions
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const offsetX = (Math.random() - 0.5) * 100;
                            const offsetY = (Math.random() - 0.5) * 100;
                            
                            gameState.explosions.push({
                                x: projectile.x + offsetX,
                                y: projectile.y + offsetY,
                                radius: 40,
                                damage: 10,
                                currentRadius: 0,
                                maxRadius: 40,
                                expandSpeed: 3,
                                life: 20
                            });
                            
                            // Create particles for secondary explosions
                            gameState.particles.push(...createExplosionParticles(
                                projectile.x + offsetX, 
                                projectile.y + offsetY, 
                                15, 
                                '#FF5722'
                            ));
                            
                            // Damage players in secondary explosion radius
                            damagePlayersInRadius(
                                projectile.x + offsetX, 
                                projectile.y + offsetY, 
                                40, 
                                10, 
                                projectile.ownerId
                            );
                        }, 300 + i * 200);
                    }
                    break;
                case 'sniper':
                    radius = 30;
                    damage = 50;
                    particleCount = 15;
                    break;
                case 'grenade':
                    radius = 120;
                    damage = 30;
                    particleCount = 50;
                    break;
                default:
                    radius = 80;
                    damage = 25;
                    particleCount = 30;
            }
            
            // Create main explosion
            gameState.explosions.push({
                x: projectile.x,
                y: projectile.y,
                radius: radius,
                damage: damage,
                currentRadius: 0,
                maxRadius: radius,
                expandSpeed: 4,
                life: 30
            });
            
            // Create particles
            gameState.particles.push(...createExplosionParticles(
                projectile.x, 
                projectile.y, 
                particleCount, 
                getExplosionColor(projectile.type)
            ));
            
            // Damage players in radius
            damagePlayersInRadius(projectile.x, projectile.y, radius, damage, projectile.ownerId);
            
            // Modify terrain for certain weapons
            if (['basic', 'missile', 'grenade'].includes(projectile.type)) {
                modifyTerrain(projectile.x, projectile.y, radius * 0.8);
            }
        }
        
        // Get color for explosion based on weapon type
        function getExplosionColor(type) {
            switch (type) {
                case 'basic': return '#FF9800';
                case 'missile': return '#F44336';
                case 'cluster': return '#9C27B0';
                case 'sniper': return '#4CAF50';
                case 'grenade': return '#FFEB3B';
                default: return '#FF9800';
            }
        }
        
        // Create explosion particles
        function createExplosionParticles(x, y, count, color) {
            const particles = [];
            
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 5;
                
                particles.push({
                    x: x,
                    y: y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    size: 5 + Math.random() * 10,
                    color: color,
                    opacity: 1,
                    life: 30 + Math.random() * 30
                });
            }
            
            return particles;
        }
        
        // Damage players in explosion radius
        function damagePlayersInRadius(x, y, radius, baseDamage, attackerId) {
            for (const player of gameState.players) {
                if (!player.alive) continue;
                
                const dx = player.x - x;
                const dy = player.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < radius) {
                    // Calculate damage based on distance (more damage closer to center)
                    const distanceFactor = 1 - (distance / radius);
                    let damage = Math.round(baseDamage * distanceFactor);
                    
                    // Apply attacker's damage multiplier
                    const attacker = gameState.players.find(p => p.id === attackerId);
                    if (attacker) {
                        damage = Math.round(damage * attacker.damageMultiplier);
                    }
                    
                    // Apply shield effect if present
                    const shieldEffect = player.effects.find(e => e.type === 'shield');
                    if (shieldEffect) {
                        damage = Math.round(damage * (1 - shieldEffect.value));
                        
                        // Create shield hit effect
                        gameState.particles.push(...createShieldHitEffect(player.x, player.y));
                    }
                    
                    // Apply damage
                    player.health = Math.max(0, player.health - damage);
                    
                    // Check if player is dead
                    if (player.health <= 0 && player.alive) {
                        player.alive = false;
                        
                        // Create death effect
                        gameState.particles.push(...createDeathEffect(player.x, player.y));
                        
                        // Check for game over
                        checkGameOver();
                    }
                    
                    // Create hit number indicator
                    createDamageNumber(player.x, player.y - 20, damage);
                }
            }
        }
        
        // Create shield hit effect
        function createShieldHitEffect(x, y) {
            const particles = [];
            
            for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                
                particles.push({
                    x: x + Math.cos(angle) * 30,
                    y: y + Math.sin(angle) * 30,
                    velocityX: Math.cos(angle) * 2,
                    velocityY: Math.sin(angle) * 2,
                    size: 10,
                    color: '#64B5F6',
                    opacity: 1,
                    life: 20 + Math.random() * 10
                });
            }
            
            return particles;
        }
        
        // Create death effect particles
        function createDeathEffect(x, y) {
            const particles = [];
            
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 5;
                
                particles.push({
                    x: x,
                    y: y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    size: 8 + Math.random() * 8,
                    color: '#F44336',
                    opacity: 1,
                    life: 60 + Math.random() * 60
                });
            }
            
            return particles;
        }
        
        // Create floating damage number
        function createDamageNumber(x, y, damage) {
            gameState.particles.push({
                x: x,
                y: y,
                velocityX: 0,
                velocityY: -1,
                text: `-${damage}`,
                color: '#F44336',
                opacity: 1,
                life: 60,
                type: 'text'
            });
        }
        
        // Modify terrain at explosion point
        function modifyTerrain(x, y, radius) {
            if (!gameState.terrain || gameState.terrain.length === 0) return;
            
            const terrain = gameState.terrain;
            const segmentWidth = 3000 / TERRAIN_SEGMENTS;
            
            // Find affected segments
            const startIndex = Math.max(0, Math.floor((x - radius) / segmentWidth));
            const endIndex = Math.min(terrain.length - 1, Math.floor((x + radius) / segmentWidth));
            
            // Modify terrain heights
            for (let i = startIndex; i <= endIndex; i++) {
                const point = terrain[i];
                const dx = point.x - x;
                const distance = Math.abs(dx);
                
                if (distance < radius) {
                    // Calculate depth based on distance from center (deeper at center)
                    const depthFactor = (radius - distance) / radius;
                    const maxDepth = 50; // Maximum terrain deformation
                    
                    // Only deform if explosion is close to or below terrain
                    if (y + 20 > point.y) {
                        // Create a crater effect
                        point.y += maxDepth * depthFactor;
                    }
                }
            }
        }
        
        // Update explosions
        function updateExplosions() {
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                
                // Expand the explosion
                if (explosion.currentRadius < explosion.maxRadius) {
                    explosion.currentRadius += explosion.expandSpeed;
                }
                
                // Decrease life
                explosion.life--;
                
                // Remove expired explosions
                if (explosion.life <= 0) {
                    gameState.explosions.splice(i, 1);
                    
                    // End turn if all explosions are gone and no projectiles remain
                    if (gameState.explosions.length === 0 && gameState.projectiles.length === 0) {
                        endTurn();
                    }
                }
            }
        }
        
        // Update particles
        function updateParticles() {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                
                // Update position
                particle.x += particle.velocityX;
                particle.y += particle.velocityY;
                
                // Apply gravity to some particles
                if (!particle.type || particle.type !== 'text') {
                    particle.velocityY += 0.1;
                }
                
                // Decrease life
                particle.life--;
                
                // Update opacity near end of life
                if (particle.life < 10) {
                    particle.opacity = particle.life / 10;
                }
                
                // Remove dead particles
                if (particle.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }
        
        // Create cloud objects
        function createClouds() {
            const clouds = [];
            
            for (let i = 0; i < CLOUD_COUNT; i++) {
                clouds.push({
                    x: Math.random() * 3000,
                    y: Math.random() * 400,
                    width: 100 + Math.random() * 150,
                    height: 50 + Math.random() * 50,
                    speed: 0.2 + Math.random() * 0.3,
                    opacity: 0.6 + Math.random() * 0.2
                });
            }
            
            return clouds;
        }
        
        // Update cloud positions
        function updateClouds() {
            if (!gameState.clouds || gameState.clouds.length === 0) {
                gameState.clouds = createClouds();
            }
            
            for (const cloud of gameState.clouds) {
                // Move clouds based on wind
                cloud.x += parseFloat(gameState.wind) * 0.1;
                
                // Wrap clouds around the map
                if (cloud.x > 3000 + cloud.width) {
                    cloud.x = -cloud.width;
                } else if (cloud.x < -cloud.width) {
                    cloud.x = 3000 + cloud.width;
                }
            }
        }
        
        // End the current turn
        function endTurn() {
            // Only the active player should send turn complete
            if (gameState.currentTurn === gameState.playerId) {
                socket.emit('turn-complete');
            }
        }
        
        // Check if the game is over
        function checkGameOver() {
            // Count alive players
            const alivePlayers = gameState.players.filter(p => p.alive);
            
            // Game is over if only one player or team remains
            if (alivePlayers.length <= 1) {
                // Show game over screen
                const winner = alivePlayers[0];
                
                document.getElementById('gameOverTitle').textContent = 
                    winner && winner.id === gameState.playerId ? 'Victory!' : 'Defeat!';
                
                document.getElementById('winnerInfo').textContent = 
                    winner ? `${winner.name} won the match!` : 'No survivors!';
                
                gameOverScreen.style.display = 'flex';
            }
        }
        
        // Render the game
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
            
            // Only render if in game
            if (gameState.screen !== 'game') return;
            
            const canvasWidth = gameCanvas.width / (window.devicePixelRatio || 1);
            const canvasHeight = gameCanvas.height / (window.devicePixelRatio || 1);
            
            // Calculate camera bounds
            const cameraX = Math.min(Math.max(gameState.camera.x - canvasWidth / 2, 0), 3000 - canvasWidth);
            const cameraY = Math.min(Math.max(gameState.camera.y - canvasHeight / 2, 0), 1500 - canvasHeight);
            
            // Draw sky background
            drawSky();
            
            // Draw clouds
            drawClouds(cameraX, cameraY);
            
            // Draw terrain
            drawTerrain(cameraX, cameraY);
            
            // Draw platforms
            drawPlatforms(cameraX, cameraY);
            
            // Draw powerups
            drawPowerups(cameraX, cameraY);
            
            // Draw players
            drawPlayers(cameraX, cameraY);
            
            // Draw projectiles
            drawProjectiles(cameraX, cameraY);
            
            // Draw explosions
            drawExplosions(cameraX, cameraY);
            
            // Draw particles
            drawParticles(cameraX, cameraY);
            
            // Draw UI elements on uiCanvas
            drawUI();
        }
        
        // Draw sky gradient background
        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
            
            if (document.documentElement.classList.contains('dark')) {
                // Night sky
                gradient.addColorStop(0, '#0F2027');
                gradient.addColorStop(0.5, '#203A43');
                gradient.addColorStop(1, '#2C5364');
            } else {
                // Day sky
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.7, '#E0F7FF');
                gradient.addColorStop(1, '#FFF9C4');
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        }
        
        // Draw clouds
        function drawClouds(cameraX, cameraY) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            
            for (const cloud of gameState.clouds) {
                const screenX = cloud.x - cameraX;
                const screenY = cloud.y - cameraY;
                
                if (screenX < -cloud.width || screenX > gameCanvas.width / (window.devicePixelRatio || 1) ||
                    screenY < -cloud.height || screenY > gameCanvas.height / (window.devicePixelRatio || 1)) {
                    continue;
                }
                
                ctx.save();
                ctx.globalAlpha = cloud.opacity;
                
                // Draw fluffy cloud shape
                ctx.beginPath();
                const radius = cloud.height / 2;
                
                // Cloud main body
                ctx.arc(screenX + radius, screenY + radius, radius, 0, Math.PI * 2);
                ctx.arc(screenX + cloud.width - radius, screenY + radius, radius, 0, Math.PI * 2);
                
                // Cloud top bumps
                const bumps = Math.floor(cloud.width / 40);
                for (let i = 1; i < bumps; i++) {
                    const bumpX = screenX + (cloud.width * i / bumps);
                    const bumpY = screenY + (Math.sin(i * 0.7) * 10);
                    const bumpRadius = 20 + Math.random() * 20;
                    ctx.arc(bumpX, bumpY, bumpRadius, 0, Math.PI * 2);
                }
                
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Draw terrain
        function drawTerrain(cameraX, cameraY) {
            if (!gameState.terrain || gameState.terrain.length < 2) return;
            
            // Draw terrain fill
            ctx.fillStyle = document.documentElement.classList.contains('dark') ? '#3E2723' : '#8B4513';
            ctx.beginPath();
            
            const firstPoint = gameState.terrain[0];
            ctx.moveTo(firstPoint.x - cameraX, firstPoint.y - cameraY);
            
            for (let i = 1; i < gameState.terrain.length; i++) {
                const point = gameState.terrain[i];
                ctx.lineTo(point.x - cameraX, point.y - cameraY);
            }
            
            // Complete the shape by extending to bottom corners
            const lastPoint = gameState.terrain[gameState.terrain.length - 1];
            ctx.lineTo(lastPoint.x - cameraX, gameCanvas.height);
            ctx.lineTo(firstPoint.x - cameraX, gameCanvas.height);
            ctx.closePath();
            ctx.fill();
            
            // Draw grass on top of terrain
            ctx.strokeStyle = document.documentElement.classList.contains('dark') ? '#33691E' : '#558B2F';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(firstPoint.x - cameraX, firstPoint.y - cameraY);
            
            for (let i = 1; i < gameState.terrain.length; i++) {
                const point = gameState.terrain[i];
                ctx.lineTo(point.x - cameraX, point.y - cameraY);
            }
            
            ctx.stroke();
        }
        
        // Draw platforms
        function drawPlatforms(cameraX, cameraY) {
            if (!gameState.platforms || gameState.platforms.length === 0) return;
            
            for (const platform of gameState.platforms) {
                const screenX = platform.x - cameraX;
                const screenY = platform.y - cameraY;
                
                if (screenX + platform.width < 0 || screenX > gameCanvas.width / (window.devicePixelRatio || 1) ||
                    screenY + platform.height < 0 || screenY > gameCanvas.height / (window.devicePixelRatio || 1)) {
                    continue;
                }
                
                // Draw platform with rounded corners
                ctx.fillStyle = document.documentElement.classList.contains('dark') ? '#5D4037' : '#8D6E63';
                
                ctx.beginPath();
                const radius = 10;
                ctx.moveTo(screenX + radius, screenY);
                ctx.lineTo(screenX + platform.width - radius, screenY);
                ctx.arc(screenX + platform.width - radius, screenY + radius, radius, -Math.PI / 2, 0);
                ctx.lineTo(screenX + platform.width, screenY + platform.height - radius);
                ctx.arc(screenX + platform.width - radius, screenY + platform.height - radius, radius, 0, Math.PI / 2);
                ctx.lineTo(screenX + radius, screenY + platform.height);
                ctx.arc(screenX + radius, screenY + platform.height - radius, radius, Math.PI / 2, Math.PI);
                ctx.lineTo(screenX, screenY + radius);
                ctx.arc(screenX + radius, screenY + radius, radius, Math.PI, Math.PI * 3 / 2);
                ctx.closePath();
                ctx.fill();
                
                // Draw grass on top
                ctx.strokeStyle = document.documentElement.classList.contains('dark') ? '#33691E' : '#558B2F';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(screenX, screenY);
                ctx.lineTo(screenX + platform.width, screenY);
                ctx.stroke();
            }
        }
        
        // Draw powerups
        function drawPowerups(cameraX, cameraY) {
            if (!gameState.powerups || gameState.powerups.length === 0) return;
            
            for (const powerup of gameState.powerups) {
                const screenX = powerup.x - cameraX;
                const screenY = powerup.y - cameraY;
                
                if (screenX < -50 || screenX > gameCanvas.width / (window.devicePixelRatio || 1) + 50 ||
                    screenY < -50 || screenY > gameCanvas.height / (window.devicePixelRatio || 1) + 50) {
                    continue;
                }
                
                // Draw powerup glow
                ctx.save();
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.005) * 0.2;
                
                const gradient = ctx.createRadialGradient(
                    screenX, screenY, 0,
                    screenX, screenY, 30
                );
                
                let color;
                switch (powerup.type) {
                    case 'health': color = '#4CAF50'; break;
                    case 'ammo': color = '#FFC107'; break;
                    case 'shield': color = '#2196F3'; break;
                    default: color = '#9C27B0';
                }
                
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw powerup icon
                ctx.globalAlpha = 1;
                ctx.font = 'bold 24px Nunito';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                let icon;
                switch (powerup.type) {
                    case 'health': icon = 'â¤ï¸'; break;
                    case 'ammo': icon = 'ðŸŽ¯'; break;
                    case 'shield': icon = 'ðŸ›¡ï¸'; break;
                    default: icon = 'âœ¨';
                }
                
                ctx.fillText(icon, screenX, screenY);
                ctx.restore();
            }
        }
        
        // Draw players
        function drawPlayers(cameraX, cameraY) {
            for (const player of gameState.players) {
                if (!player.alive) continue;
                
                const screenX = player.x - cameraX;
                const screenY = player.y - cameraY;
                
                if (screenX < -50 || screenX > gameCanvas.width / (window.devicePixelRatio || 1) + 50 ||
                    screenY < -50 || screenY > gameCanvas.height / (window.devicePixelRatio || 1) + 50) {
                    continue;
                }
                
                // Draw player
                const character = gameState.characters.find(c => c.id === player.character);
                
                if (!character) continue;
                
                // Draw shield effect if present
                const shieldEffect = player.effects.find(e => e.type === 'shield');
                if (shieldEffect) {
                    ctx.save();
                    ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.005) * 0.1;
                    ctx.strokeStyle = '#64B5F6';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 40, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw player circle
                ctx.fillStyle = character.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw character icon
                ctx.font = 'bold 20px Nunito';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'white';
                ctx.fillText(character.icon, screenX, screenY);
                
                // Draw weapon if current turn
                if (player.id === gameState.currentTurn) {
                    // Determine aim direction
                    const angle = player.facingLeft ? 
                        Math.PI - gameState.angle * Math.PI / 180 :
                        gameState.angle * Math.PI / 180;
                    
                    const weaponLength = 30;
                    const weaponEndX = screenX + Math.cos(angle) * weaponLength;
                    const weaponEndY = screenY - Math.sin(angle) * weaponLength;
                    
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(weaponEndX, weaponEndY);
                    ctx.stroke();
                    
                    // Draw power indicator
                    if (player.id === gameState.playerId) {
                        const powerIndicatorLength = (gameState.power / 100) * 60;
                        
                        ctx.strokeStyle = 'rgba(255, 152, 0, 0.7)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(weaponEndX, weaponEndY);
                        ctx.lineTo(
                            weaponEndX + Math.cos(angle) * powerIndicatorLength,
                            weaponEndY - Math.sin(angle) * powerIndicatorLength
                        );
                        ctx.stroke();
                    }
                }
                
                // Draw player name above
                ctx.font = '14px Nunito';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(player.name, screenX, screenY - 40);
                ctx.fillText(player.name, screenX, screenY - 40);
                
                // Draw health bar
                const healthBarWidth = 60;
                const healthBarHeight = 8;
                const healthPercent = player.health / player.maxHealth;
                
                // Health bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(
                    screenX - healthBarWidth / 2,
                    screenY - 30,
                    healthBarWidth,
                    healthBarHeight
                );
                
                // Health bar fill
                ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : (healthPercent > 0.25 ? '#FFC107' : '#F44336');
                ctx.fillRect(
                    screenX - healthBarWidth / 2,
                    screenY - 30,
                    healthBarWidth * healthPercent,
                    healthBarHeight
                );
                
                // Turn indicator for current player
                if (player.id === gameState.currentTurn) {
                    ctx.fillStyle = '#4CAF50';
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY - 60);
                    ctx.lineTo(screenX - 10, screenY - 50);
                    ctx.lineTo(screenX + 10, screenY - 50);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }
        
        // Draw projectiles
        function drawProjectiles(cameraX, cameraY) {
            for (const proj of gameState.projectiles) {
                const screenX = proj.x - cameraX;
                const screenY = proj.y - cameraY;
                
                if (screenX < -50 || screenX > gameCanvas.width / (window.devicePixelRatio || 1) + 50 ||
                    screenY < -50 || screenY > gameCanvas.height / (window.devicePixelRatio || 1) + 50) {
                    continue;
                }
                
                // Draw projectile based on type
                switch (proj.type) {
                    case 'basic':
                        // Draw basic bomb
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw fuse
                        ctx.strokeStyle = '#FFA000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY - 8);
                        ctx.lineTo(screenX, screenY - 15);
                        ctx.stroke();
                        
                        // Draw spark
                        if (Math.random() > 0.5) {
                            ctx.fillStyle = '#FFF176';
                            ctx.beginPath();
                            ctx.arc(screenX, screenY - 15, 2 + Math.random() * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    
                    case 'missile':
                        // Draw missile body
                        ctx.save();
                        
                        // Rotate in direction of movement
                        const angle = Math.atan2(proj.velocityY, proj.velocityX);
                        ctx.translate(screenX, screenY);
                        ctx.rotate(angle);
                        
                        // Missile body
                        ctx.fillStyle = '#F44336';
                        ctx.beginPath();
                        ctx.moveTo(10, 0);
                        ctx.lineTo(-10, -5);
                        ctx.lineTo(-10, 5);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Missile fins
                        ctx.fillStyle = '#B71C1C';
                        ctx.beginPath();
                        ctx.moveTo(-8, 0);
                        ctx.lineTo(-15, -8);
                        ctx.lineTo(-10, -8);
                        ctx.lineTo(-10, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.moveTo(-8, 0);
                        ctx.lineTo(-15, 8);
                        ctx.lineTo(-10, 8);
                        ctx.lineTo(-10, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Exhaust flame
                        if (Math.random() > 0.3) {
                            ctx.fillStyle = '#FFA000';
                            ctx.beginPath();
                            ctx.moveTo(-10, 0);
                            ctx.lineTo(-20 - Math.random() * 10, -3 - Math.random() * 2);
                            ctx.lineTo(-20 - Math.random() * 10, 3 + Math.random() * 2);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        ctx.restore();
                        break;
                    
                    case 'cluster':
                        // Draw cluster bomb
                        ctx.fillStyle = '#9C27B0';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw multiple fuses
                        for (let i = 0; i < 3; i++) {
                            const angle = (i / 3) * Math.PI * 2 + Date.now() * 0.005;
                            const fuseLength = 8 + Math.random() * 5;
                            
                            ctx.strokeStyle = '#FFA000';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY);
                            ctx.lineTo(
                                screenX + Math.cos(angle) * fuseLength,
                                screenY + Math.sin(angle) * fuseLength
                            );
                            ctx.stroke();
                            
                            // Draw spark
                            if (Math.random() > 0.7) {
                                ctx.fillStyle = '#FFF176';
                                ctx.beginPath();
                                ctx.arc(
                                    screenX + Math.cos(angle) * fuseLength,
                                    screenY + Math.sin(angle) * fuseLength,
                                    2 + Math.random() * 2, 0, Math.PI * 2
                                );
                                ctx.fill();
                            }
                        }
                        break;
                    
                    case 'sniper':
                        // Draw sniper bullet
                        ctx.save();
                        
                        // Rotate in direction of movement
                        const bulletAngle = Math.atan2(proj.velocityY, proj.velocityX);
                        ctx.translate(screenX, screenY);
                        ctx.rotate(bulletAngle);
                        
                        // Bullet body
                        ctx.fillStyle = '#FFC107';
                        ctx.beginPath();
                        ctx.moveTo(12, 0);
                        ctx.lineTo(0, -2);
                        ctx.lineTo(-8, -2);
                        ctx.lineTo(-8, 2);
                        ctx.lineTo(0, 2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Bullet trail
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(-8, 0);
                        ctx.lineTo(-30, 0);
                        ctx.stroke();
                        
                        ctx.restore();
                        break;
                    
                    case 'grenade':
                        // Draw grenade
                        ctx.fillStyle = '#4CAF50';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw grenade details
                        ctx.fillStyle = '#333';
                        ctx.fillRect(screenX - 3, screenY - 10, 6, 4);
                        
                        // Draw pin
                        ctx.strokeStyle = '#BDBDBD';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(screenX + 3, screenY - 8);
                        ctx.lineTo(screenX + 8, screenY - 12);
                        ctx.lineTo(screenX + 12, screenY - 10);
                        ctx.stroke();
                        break;
                    
                    default:
                        // Default projectile
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 6, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
            }
        }
        
        // Draw explosions
        function drawExplosions(cameraX, cameraY) {
            for (const explosion of gameState.explosions) {
                const screenX = explosion.x - cameraX;
                const screenY = explosion.y - cameraY;
                
                if (screenX < -explosion.maxRadius || screenX > gameCanvas.width / (window.devicePixelRatio || 1) + explosion.maxRadius ||
                    screenY < -explosion.maxRadius || screenY > gameCanvas.height / (window.devicePixelRatio || 1) + explosion.maxRadius) {
                    continue;
                }
                
                // Draw explosion
                const gradient = ctx.createRadialGradient(
                    screenX, screenY, 0,
                    screenX, screenY, explosion.currentRadius
                );
                
                // Fade out as life decreases
                const opacity = Math.min(1, explosion.life / 20);
                
                gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                gradient.addColorStop(0.3, `rgba(255, 200, 0, ${opacity})`);
                gradient.addColorStop(0.7, `rgba(255, 100, 0, ${opacity})`);
                gradient.addColorStop(1, `rgba(255, 0, 0, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenX, screenY, explosion.currentRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw particles
        function drawParticles(cameraX, cameraY) {
            for (const particle of gameState.particles) {
                const screenX = particle.x - cameraX;
                const screenY = particle.y - cameraY;
                
                if (particle.type === 'text') {
                    // Draw text particles (damage numbers, etc.)
                    ctx.save();
                    ctx.globalAlpha = particle.opacity;
                    ctx.font = 'bold 18px Nunito';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = particle.color;
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(particle.text, screenX, screenY);
                    ctx.fillText(particle.text, screenX, screenY);
                    ctx.restore();
                } else {
                    // Draw regular particles
                    ctx.save();
                    ctx.globalAlpha = particle.opacity;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }
        
        // Draw UI elements
        function drawUI() {
            // Draw angle indicator
            if (gameState.isMyTurn) {
                const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
                if (currentPlayer) {
                    const canvasWidth = uiCanvas.width / (window.devicePixelRatio || 1);
                    const canvasHeight = uiCanvas.height / (window.devicePixelRatio || 1);
                    
                    // Draw angle text
                    uiCtx.font = '18px Nunito';
                    uiCtx.fillStyle = 'white';
                    uiCtx.textAlign = 'center';
                    uiCtx.fillText(`Angle: ${gameState.angle}Â°`, 70, canvasHeight - 70);
                    
                    // Draw power text
                    uiCtx.fillText(`Power: ${gameState.power}%`, canvasWidth - 70, canvasHeight - 70);
                    
                    // Update wind indicator
                    document.getElementById('windText').textContent = `Wind: ${gameState.wind} m/s`;
                    document.getElementById('windArrow').innerHTML = parseFloat(gameState.wind) > 0 ? 'â†’' : (parseFloat(gameState.wind) < 0 ? 'â†' : 'â€¢');
                }
            }
            
            // Update turn indicator
            const turnText = document.getElementById('turnText');
            if (gameState.isMyTurn) {
                turnText.textContent = 'Your Turn';
            } else {
                const currentPlayer = gameState.players.find(p => p.id === gameState.currentTurn);
                if (currentPlayer) {
                    turnText.textContent = `${currentPlayer.name}'s Turn`;
                }
            }
            
            // Update weapon name
            document.getElementById('weaponName').textContent = gameState.inventory[gameState.selectedWeapon].name;
        }
        
        // Set up socket event handlers
        function setupSocketEvents() {
            socket.on('connect', () => {
                console.log('Connected to server');
                gameState.playerId = socket.id;
                
                // Join game
                socket.emit('join-game', { playerName: gameState.playerName }, (response) => {
                    if (!response.success) {
                        showToast('Failed to join game: ' + response.message);
                    }
                });
            });
            
            socket.on('rooms-updated', () => {
                // Update rooms list if on room screen
                if (gameState.screen === 'roomList') {
                    fetchRooms();
                }
            });
            
            socket.on('player-joined', (data) => {
                if (gameState.roomId) {
                    // Add player to room
                    gameState.players.push(data.player);
                    
                    // Update waiting room
                    updateWaitingRoomPlayers();
                    
                    // Show notification
                    addChatMessage(null, `${data.player.name} joined the room`, true);
                }
            });
            
            socket.on('player-left', (data) => {
                if (gameState.roomId) {
                    // Remove player from room
                    gameState.players = gameState.players.filter(p => p.id !== data.playerId);
                    
                    // Update waiting room
                    updateWaitingRoomPlayers();
                    
                    // Show notification
                    addChatMessage(null, `${data.playerName} left the room`, true);
                }
            });
            
            socket.on('owner-changed', (data) => {
                if (gameState.roomId) {
                    // Update room owner
                    gameState.players.forEach(player => {
                        player.isOwner = player.id === data.owner.id;
                    });
                    
                    // Check if I'm the new owner
                    gameState.isRoomOwner = data.owner.id === gameState.playerId;
                    
                    // Update UI
                    if (gameState.isRoomOwner) {
                        document.getElementById('startGameBtn').style.display = 'block';
                        document.getElementById('mapSelectionContainer').style.display = 'block';
                    }
                    
                    // Update waiting room
                    updateWaitingRoomPlayers();
                    
                    // Show notification
                    addChatMessage(null, `${data.owner.name} is now the room owner`, true);
                }
            });
            
            socket.on('game-started', (data) => {
                // Set up game state
                gameState.terrain = data.map.terrain;
                gameState.platforms = data.map.platforms;
                gameState.players = data.players;
                gameState.currentTurn = data.currentTurn;
                gameState.isMyTurn = data.currentTurn === gameState.playerId;
                gameState.wind = data.wind;
                
                // Reset game objects
                gameState.projectiles = [];
                gameState.explosions = [];
                gameState.particles = [];
                gameState.powerups = [];
                
                // Set player facingLeft based on position
                gameState.players.forEach(player => {
                    // Players on left half face right, on right half face left
                    player.facingLeft = player.x > data.map.width / 2;
                });
                
                // Initialize camera position to own player
                const ownPlayer = gameState.players.find(p => p.id === gameState.playerId);
                if (ownPlayer) {
                    gameState.camera.x = ownPlayer.x;
                    gameState.camera.y = ownPlayer.y;
                    gameState.camera.targetX = ownPlayer.x;
                    gameState.camera.targetY = ownPlayer.y;
                }
                
                // Initialize clouds
                gameState.clouds = createClouds();
                
                // Switch to game screen
                waitingRoom.style.display = 'none';
                gameUI.style.display = 'block';
                gameState.screen = 'game';
                
                // Show game started notification
                addChatMessage(null, 'Game started!', true);
                
                // Reset inventory for new game
                gameState.inventory = {
                    basic: { type: 'weapon', name: 'Basic Cannon', icon: 'ðŸ’£', ammo: -1 },
                    missile: { type: 'weapon', name: 'Missile', icon: 'ðŸš€', ammo: 5 },
                    cluster: { type: 'weapon', name: 'Cluster Bomb', icon: 'ðŸ§¨', ammo: 3 },
                    sniper: { type: 'weapon', name: 'Sniper Shot', icon: 'ðŸŽ¯', ammo: 3 },
                    grenade: { type: 'weapon', name: 'Grenade', icon: 'ðŸ’¥', ammo: 3 },
                    healthpack: { type: 'item', name: 'Health Pack', icon: 'â¤ï¸', ammo: 2 },
                    shield: { type: 'item', name: 'Shield', icon: 'ðŸ›¡ï¸', ammo: 1 }
                };
                
                populateInventory();
            });
            
            socket.on('turn-changed', (data) => {
                // Update turn
                gameState.currentTurn = data.playerId;
                gameState.isMyTurn = data.playerId === gameState.playerId;
                gameState.wind = data.wind;
                
                // Focus camera on current player
                const currentPlayer = gameState.players.find(p => p.id === data.playerId);
                if (currentPlayer) {
                    gameState.camera.targetX = currentPlayer.x;
                    gameState.camera.targetY = currentPlayer.y;
                }
                
                // Reduce duration of effects
                gameState.players.forEach(player => {
                    player.effects = player.effects.filter(effect => {
                        if (effect.duration > 0) {
                            effect.duration--;
                            return true;
                        }
                        return false;
                    });
                });
                
                // Show turn change notification
                const playerName = currentPlayer ? currentPlayer.name : 'Unknown player';
                addChatMessage(null, `${playerName}'s turn`, true);
                
                // Reset angle and power for new turn
                if (gameState.isMyTurn) {
                    gameState.angle = 45;
                    gameState.power = 50;
                }
            });
            
            socket.on('projectile-update', (data) => {
                // For simplicity, we're handling projectiles entirely client-side
                // But the server could validate or broadcast important updates
            });
            
            socket.on('chat-message', (data) => {
                addChatMessage(data.sender, data.message);
            });
            
            socket.on('all-players-ready', () => {
                // Notification that all players are ready for a new game
                addChatMessage(null, 'All players are ready. Starting new game...', true);
            });
            
            socket.on('disconnect', () => {
                showToast('Disconnected from server');
                
                // Go back to menu
                if (gameState.screen === 'game' || gameState.screen === 'waiting') {
                    menuScreen.style.display = 'flex';
                    waitingRoom.style.display = 'none';
                    gameUI.style.display = 'none';
                    gameState.screen = 'menu';
                }
            });
        }
        
        // Initialize the game
        init();
    </script>
</body>
</html>
