<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pháo Thủ - Trò Chơi Bắn Súng Theo Lượt</title>
    <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4.6.1/dist/socket.io.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#4CAF50',
                        danger: '#F44336',
                        warning: '#FFC107',
                        info: '#2196F3',
                    },
                    animation: {
                        'bounce-slow': 'bounce 3s infinite',
                        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'float': 'float 3s ease-in-out infinite',
                        'flash': 'flash 2s infinite',
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        },
                        flash: {
                            '0%, 100%': { opacity: 1 },
                            '50%': { opacity: 0.5 },
                        }
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Nunito', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #uiCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        .game-ui {
            position: absolute;
            z-index: 3;
            pointer-events: auto;
        }
        
        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            user-select: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        
        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .angle-btn {
            background: linear-gradient(135deg, #ff7e5f, #feb47b);
        }
        
        .power-btn {
            background: linear-gradient(135deg, #6a11cb, #2575fc);
        }
        
        .fire-btn {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #FF416C, #FF4B2B);
            font-size: 20px;
            font-weight: bold;
        }
        
        .inventory-btn {
            background: linear-gradient(135deg, #F09819, #EDDE5D);
        }
        
        .move-btn {
            background: linear-gradient(135deg, #56ab2f, #a8e063);
        }
        
        .weapon-indicator {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 20px;
            font-weight: bold;
            z-index: 3;
        }
        
        .player-info {
            position: absolute;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 12px;
            font-weight: bold;
            z-index: 3;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .health-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF416C, #FF4B2B);
            transition: width 0.3s ease;
        }
        
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #6441A5, #2a0845);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .loader {
            width: 80px;
            height: 80px;
            border: 8px solid rgba(255, 255, 255, 0.1);
            border-left-color: #5D5CDE;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #menuScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://i.imgur.com/MWvA6l5.jpg') no-repeat center center;
            background-size: cover;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 900;
        }
        
        #menuScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: -1;
        }
        
        .menu-container {
            max-width: 500px;
            width: 90%;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .menu-title {
            font-size: 2.5rem;
            font-weight: bold;
            color: white;
            text-align: center;
            margin-bottom: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .input-group {
            margin-bottom: 1rem;
        }
        
        .input-label {
            display: block;
            margin-bottom: 0.5rem;
            color: white;
            font-weight: bold;
        }
        
        .input-field {
            width: 100%;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            color: white;
            outline: none;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        
        .input-field::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .input-field:focus {
            border-color: #5D5CDE;
            box-shadow: 0 0 0 3px rgba(93, 92, 222, 0.3);
        }
        
        .menu-btn {
            display: block;
            width: 100%;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            font-weight: bold;
            text-align: center;
            background: #5D5CDE;
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: transform 0.3s, background 0.3s;
            margin-top: 1rem;
        }
        
        .menu-btn:hover {
            background: #4a49b8;
        }
        
        .menu-btn:active {
            transform: scale(0.98);
        }
        
        .menu-divider {
            display: flex;
            align-items: center;
            margin: 1.5rem 0;
            color: white;
        }
        
        .menu-divider::before,
        .menu-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255, 255, 255, 0.3);
        }
        
        .menu-divider span {
            padding: 0 1rem;
        }
        
        #roomScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #43cea2, #185a9d);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 800;
        }
        
        .rooms-container {
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .room-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            margin-bottom: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            color: white;
            transition: background 0.3s;
        }
        
        .room-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .room-name {
            font-weight: bold;
            margin-right: 1rem;
        }
        
        .room-info {
            font-size: 0.875rem;
            opacity: 0.8;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            font-weight: bold;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .toast.show {
            opacity: 1;
        }
        
        .character-selection {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
            overflow-x: auto;
            padding: 0.5rem;
        }
        
        .character-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            transition: transform 0.2s, background 0.2s;
        }
        
        .character-option.selected {
            background: rgba(93, 92, 222, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 0 2px #5D5CDE;
        }
        
        .character-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .character-preview {
            width: 60px;
            height: 60px;
            margin-bottom: 0.5rem;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
        }
        
        .character-name {
            color: white;
            font-size: 0.875rem;
            text-align: center;
        }
        
        .character-stats {
            display: none;
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 0.5rem;
            color: white;
            font-size: 0.75rem;
            text-align: left;
            width: 200px;
            position: absolute;
            z-index: 10;
        }
        
        .character-option:hover .character-stats {
            display: block;
        }
        
        #mapSelectionContainer {
            margin-top: 1.5rem;
            width: 100%;
        }
        
        .map-selection {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 0.5rem;
            overflow-x: auto;
            padding: 0.5rem;
        }
        
        .map-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            transition: transform 0.2s, background 0.2s;
        }
        
        .map-option.selected {
            background: rgba(93, 92, 222, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 0 2px #5D5CDE;
        }
        
        .map-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .map-preview {
            width: 100px;
            height: 60px;
            margin-bottom: 0.5rem;
            border-radius: 0.25rem;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .map-name {
            color: white;
            font-size: 0.875rem;
            text-align: center;
        }
        
        .waiting-room {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2b5876, #4e4376);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 750;
        }
        
        .waiting-container {
            max-width: 500px;
            width: 90%;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        
        .players-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .player-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            min-width: 100px;
        }
        
        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
            margin-bottom: 0.5rem;
        }
        
        .player-name {
            color: white;
            font-weight: bold;
            margin-bottom: 0.25rem;
        }
        
        .player-status {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .waiting-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            margin-bottom: 1rem;
        }
        
        .waiting-subtitle {
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 2rem;
        }
        
        .pulse-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            background-color: #5D5CDE;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
        }
        
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }
        
        .game-over-container {
            max-width: 500px;
            width: 90%;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        
        .game-over-title {
            font-size: 2.5rem;
            font-weight: bold;
            color: white;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .win-animation {
            animation: scale-up 0.5s cubic-bezier(0.165, 0.84, 0.44, 1);
        }
        
        @keyframes scale-up {
            from {
                transform: scale(0);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .winner-info {
            margin-bottom: 2rem;
            color: white;
        }
        
        .inventory-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            padding: 1rem;
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
            transform: translateY(100%);
            transition: transform 0.3s;
            z-index: 10;
        }
        
        .inventory-panel.show {
            transform: translateY(0);
        }
        
        .inventory-title {
            color: white;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }
        
        .inventory-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            color: white;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .inventory-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .inventory-item.selected {
            background: rgba(93, 92, 222, 0.5);
            box-shadow: 0 0 0 2px #5D5CDE;
        }
        
        .inventory-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
        }
        
        .inventory-name {
            font-size: 0.75rem;
            text-align: center;
        }
        
        .close-inventory {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            font-size: 1.25rem;
        }
        
        .turn-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 20px;
            font-weight: bold;
            z-index: 3;
            display: flex;
            align-items: center;
        }
        
        .turn-icon {
            width: 24px;
            height: 24px;
            margin-right: 8px;
            border-radius: 50%;
            background: #5D5CDE;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .wind-indicator {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 20px;
            font-weight: bold;
            z-index: 3;
            display: flex;
            align-items: center;
        }
        
        .wind-arrow {
            width: 24px;
            height: 24px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .timer-indicator {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 20px;
            font-weight: bold;
            z-index: 3;
            display: flex;
            align-items: center;
        }
        
        .timer-icon {
            width: 24px;
            height: 24px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .timer-text.warning {
            color: #FFC107;
            animation: flash 1s infinite;
        }
        
        .timer-text.danger {
            color: #F44336;
            animation: flash 0.5s infinite;
        }
        
        .chat-container {
            position: absolute;
            bottom: 80px;
            left: 10px;
            width: 300px;
            max-width: calc(100% - 20px);
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            z-index: 5;
            transform: translateX(-320px);
            transition: transform 0.3s;
        }
        
        .chat-container.show {
            transform: translateX(0);
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .chat-input-container {
            display: flex;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
        }
        
        .chat-input {
            flex: 1;
            padding: 8px 12px;
            border-radius: 20px;
            border: none;
            outline: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        .chat-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .chat-send {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #5D5CDE;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
            cursor: pointer;
        }
        
        .chat-message {
            margin-bottom: 8px;
            font-size: 14px;
            color: white;
        }
        
        .chat-name {
            font-weight: bold;
            margin-right: 6px;
        }
        
        .system-message {
            color: #FFC107;
            font-style: italic;
        }
        
        .chat-toggle {
            position: absolute;
            bottom: 80px;
            left: 10px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 4;
            font-size: 20px;
        }
        
        .angle-indicator {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            pointer-events: none;
            z-index: 3;
        }
        
        .angle-line {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 2px;
            background: #5D5CDE;
            transform-origin: 0 0;
            pointer-events: none;
        }
        
        .angle-value {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-weight: bold;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        .power-bar-container {
            position: absolute;
            width: 150px;
            height: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            z-index: 3;
        }
        
        .power-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFEB3B, #F44336);
            width: 0%;
            transition: width 0.1s;
        }
        
        .power-value {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-weight: bold;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        .teleport-crosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 100;
            display: none;
        }
        
        .teleport-crosshair::before,
        .teleport-crosshair::after {
            content: '';
            position: absolute;
            background: #F44336;
        }
        
        .teleport-crosshair::before {
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            transform: translateY(-50%);
        }
        
        .teleport-crosshair::after {
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            transform: translateX(-50%);
        }
        
        .teleport-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 90;
            cursor: crosshair;
            display: none;
        }
        
        .move-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 90;
            cursor: pointer;
            display: none;
        }
        
        .move-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 10px;
            z-index: 91;
        }
        
        .move-range {
            position: absolute;
            border: 2px dashed rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            z-index: 91;
            pointer-events: none;
        }
        
        .language-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
            font-weight: bold;
        }
        
        @media (max-width: 640px) {
            .inventory-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        .dark {
            color-scheme: dark;
        }
    </style>
</head>
<body>
    <button id="languageToggle" class="language-toggle">EN/VI</button>
    
    <div id="loadingScreen">
        <div class="loader"></div>
        <p class="mt-4 text-white font-bold" data-lang="loading">Đang tải trò chơi...</p>
    </div>
    
    <div id="menuScreen">
        <div class="menu-container">
            <h1 class="menu-title" data-lang="game-title">Pháo Thủ</h1>
            <div class="input-group">
                <label for="playerName" class="input-label" data-lang="your-name">Tên của bạn</label>
                <input type="text" id="playerName" class="input-field" data-lang-placeholder="name-placeholder" placeholder="Nhập tên của bạn" maxlength="15">
            </div>
            
            <div class="character-selection">
                <!-- Character options will be generated here -->
            </div>
            
            <button id="createRoomBtn" class="menu-btn" data-lang="create-room">Tạo Phòng</button>
            
            <div class="menu-divider">
                <span data-lang="or">hoặc</span>
            </div>
            
            <button id="joinRoomBtn" class="menu-btn" data-lang="join-room">Tham Gia Phòng</button>
        </div>
    </div>
    
    <div id="roomScreen" style="display: none;">
        <div class="rooms-container">
            <h1 class="menu-title" data-lang="available-rooms">Phòng Hiện Có</h1>
            <div id="roomsList">
                <!-- Room list items will be generated here -->
            </div>
            <div class="mt-4 flex justify-between">
                <button id="refreshRoomsBtn" class="menu-btn w-auto px-4" data-lang="refresh">Làm Mới</button>
                <button id="backToMenuBtn" class="menu-btn w-auto px-4" data-lang="back">Quay Lại</button>
            </div>
        </div>
    </div>
    
    <div id="waitingRoom" class="waiting-room" style="display: none;">
        <div class="waiting-container">
            <h2 class="waiting-title" data-lang="waiting-for-players">Đang Chờ Người Chơi</h2>
            <div id="roomCode" class="mb-4 bg-white/10 py-2 px-4 rounded-md inline-block">
                <span data-lang="room-code">Mã Phòng:</span> <span id="roomCodeValue" class="font-bold">XXXX</span>
            </div>
            <p class="waiting-subtitle"><span class="pulse-dot"></span> <span data-lang="waiting-message">Đang chờ người chơi tham gia...</span></p>
            
            <div class="players-list" id="waitingPlayersList">
                <!-- Players will be added here -->
            </div>
            
            <div id="mapSelectionContainer" style="display: none;">
                <h3 class="text-white font-bold mb-2" data-lang="select-map">Chọn Bản Đồ</h3>
                <div class="map-selection" id="mapSelectionList">
                    <!-- Map options will be generated here -->
                </div>
            </div>
            
            <div class="flex justify-between mt-4">
                <button id="leaveRoomBtn" class="menu-btn w-auto px-4" data-lang="leave-room">Rời Phòng</button>
                <button id="startGameBtn" class="menu-btn w-auto px-4" style="display: none;" data-lang="start-game">Bắt Đầu</button>
            </div>
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    <canvas id="uiCanvas"></canvas>
    
    <div id="gameUI" style="display: none;">
        <div class="turn-indicator">
            <div class="turn-icon">🎯</div>
            <span id="turnText" data-lang="your-turn">Lượt Của Bạn</span>
        </div>
        
        <div class="wind-indicator">
            <div class="wind-arrow" id="windArrow">→</div>
            <span id="windText" data-lang="wind">Gió: 0 m/s</span>
        </div>
        
        <div class="timer-indicator">
            <div class="timer-icon">⏱️</div>
            <span id="timerText" class="timer-text" data-lang="time">Thời gian: 30s</span>
        </div>
        
        <div class="weapon-indicator">
            <span id="weaponName">Đại Bác</span>
        </div>
        
        <div class="angle-indicator" id="angleIndicator">
            <div class="angle-line" id="angleLine"></div>
            <div class="angle-value" id="angleValue">45°</div>
        </div>
        
        <div class="power-bar-container" id="powerBarContainer">
            <div class="power-bar" id="powerBar"></div>
            <div class="power-value" id="powerValue">50%</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; left: 20px;">
            <div class="control-btn angle-btn" id="angleDownBtn">-</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; left: 80px;">
            <div class="control-btn angle-btn" id="angleUpBtn">+</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; right: 80px;">
            <div class="control-btn power-btn" id="powerDownBtn">-</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; right: 20px;">
            <div class="control-btn power-btn" id="powerUpBtn">+</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; left: 50%; transform: translateX(-50%);">
            <div class="control-btn fire-btn" id="fireBtn" data-lang="fire">BẮN!</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; left: 160px;">
            <div class="control-btn inventory-btn" id="inventoryBtn">🎒</div>
        </div>
        
        <div class="game-ui" style="bottom: 20px; left: 220px;">
            <div class="control-btn move-btn" id="moveBtn">🏃</div>
        </div>
        
        <div class="game-ui chat-toggle" id="chatToggleBtn">💬</div>
        
        <div class="chat-container" id="chatContainer">
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" data-lang-placeholder="chat-placeholder" placeholder="Nhập tin nhắn...">
                <div class="chat-send" id="chatSendBtn">➤</div>
            </div>
        </div>
        
        <div class="inventory-panel" id="inventoryPanel">
            <div class="inventory-title" data-lang="inventory">Vũ Khí & Vật Phẩm</div>
            <div class="inventory-grid" id="inventoryGrid">
                <!-- Inventory items will be generated here -->
            </div>
            <div class="close-inventory" id="closeInventoryBtn">×</div>
        </div>
        
        <div class="teleport-overlay" id="teleportOverlay">
            <div class="move-info" data-lang="teleport-instruction">Chọn vị trí để dịch chuyển</div>
        </div>
        <div class="teleport-crosshair" id="teleportCrosshair"></div>
        
        <div class="move-overlay" id="moveOverlay">
            <div class="move-info" data-lang="move-instruction">Chọn vị trí để di chuyển (giới hạn khoảng cách)</div>
            <div class="move-range" id="moveRange"></div>
        </div>
    </div>
    
    <div id="gameOverScreen" class="game-over" style="display: none;">
        <div class="game-over-container win-animation">
            <h1 class="game-over-title" id="gameOverTitle" data-lang="victory">Chiến Thắng!</h1>
            <div class="winner-info" id="winnerInfo" data-lang="winner-message">
                Người chơi đã thắng trận đấu!
            </div>
            <button id="playAgainBtn" class="menu-btn" data-lang="play-again">Chơi Lại</button>
            <button id="exitGameBtn" class="menu-btn mt-4" data-lang="exit-to-menu">Về Menu</button>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>
    
    <script>
        // Language support
        const languages = {
            vi: {
                "loading": "Đang tải trò chơi...",
                "game-title": "Pháo Thủ",
                "your-name": "Tên của bạn",
                "name-placeholder": "Nhập tên của bạn",
                "create-room": "Tạo Phòng",
                "or": "hoặc",
                "join-room": "Tham Gia Phòng",
                "available-rooms": "Phòng Hiện Có",
                "refresh": "Làm Mới",
                "back": "Quay Lại",
                "waiting-for-players": "Đang Chờ Người Chơi",
                "room-code": "Mã Phòng:",
                "waiting-message": "Đang chờ người chơi tham gia...",
                "select-map": "Chọn Bản Đồ",
                "leave-room": "Rời Phòng",
                "start-game": "Bắt Đầu",
                "your-turn": "Lượt Của Bạn",
                "wind": "Gió: 0 m/s",
                "time": "Thời gian: 30s",
                "fire": "BẮN!",
                "inventory": "Vũ Khí & Vật Phẩm",
                "chat-placeholder": "Nhập tin nhắn...",
                "victory": "Chiến Thắng!",
                "defeat": "Thất Bại!",
                "winner-message": "Người chơi đã thắng trận đấu!",
                "play-again": "Chơi Lại",
                "exit-to-menu": "Về Menu",
                "teleport-instruction": "Chọn vị trí để dịch chuyển",
                "move-instruction": "Chọn vị trí để di chuyển (giới hạn khoảng cách)",
                "players": "Người chơi:",
                "waiting": "Đang chờ",
                "owner": "Chủ phòng",
                "no-rooms": "Không có phòng nào. Hãy tạo phòng mới!",
                "loading-rooms": "Đang tải danh sách phòng...",
                "room": "Phòng",
                "turn-other": "Lượt của {name}"
            },
            en: {
                "loading": "Loading game...",
                "game-title": "Artillery Battle",
                "your-name": "Your Name",
                "name-placeholder": "Enter your name",
                "create-room": "Create Room",
                "or": "or",
                "join-room": "Join Room",
                "available-rooms": "Available Rooms",
                "refresh": "Refresh",
                "back": "Back",
                "waiting-for-players": "Waiting for Players",
                "room-code": "Room Code:",
                "waiting-message": "Waiting for players to join...",
                "select-map": "Select Map",
                "leave-room": "Leave Room",
                "start-game": "Start Game",
                "your-turn": "Your Turn",
                "wind": "Wind: 0 m/s",
                "time": "Time: 30s",
                "fire": "FIRE!",
                "inventory": "Weapons & Items",
                "chat-placeholder": "Type a message...",
                "victory": "Victory!",
                "defeat": "Defeat!",
                "winner-message": "Player won the match!",
                "play-again": "Play Again",
                "exit-to-menu": "Exit to Menu",
                "teleport-instruction": "Select a location to teleport",
                "move-instruction": "Select a location to move (distance limited)",
                "players": "Players:",
                "waiting": "Waiting",
                "owner": "Room Owner",
                "no-rooms": "No rooms available. Create a new one!",
                "loading-rooms": "Loading rooms...",
                "room": "Room",
                "turn-other": "{name}'s Turn"
            }
        };
        
        let currentLanguage = 'vi';
        
        function setLanguage(lang) {
            currentLanguage = lang;
            
            // Update all elements with data-lang attribute
            document.querySelectorAll('[data-lang]').forEach(el => {
                const key = el.getAttribute('data-lang');
                if (languages[lang][key]) {
                    el.textContent = languages[lang][key];
                }
            });
            
            // Update placeholders
            document.querySelectorAll('[data-lang-placeholder]').forEach(el => {
                const key = el.getAttribute('data-lang-placeholder');
                if (languages[lang][key]) {
                    el.placeholder = languages[lang][key];
                }
            });
            
            // Update dynamic content that's currently shown
            updateDynamicLanguage();
        }
        
        function updateDynamicLanguage() {
            // Update turn text
            const turnText = document.getElementById('turnText');
            if (turnText.dataset.playerName) {
                turnText.textContent = languages[currentLanguage]['turn-other'].replace('{name}', turnText.dataset.playerName);
            }
            
            // Update weapon name based on selected weapon
            updateWeaponName();
            
            // Update any other dynamic content here
        }
        
        function updateWeaponName() {
            const weaponName = document.getElementById('weaponName');
            if (gameState.selectedWeapon && gameState.weapons) {
                const weapon = gameState.weapons[gameState.selectedWeapon];
                if (weapon) {
                    weaponName.textContent = currentLanguage === 'vi' ? weapon.viName : weapon.name;
                }
            }
        }
        
        document.getElementById('languageToggle').addEventListener('click', () => {
            setLanguage(currentLanguage === 'vi' ? 'en' : 'vi');
        });
        
        // Constants
        const GRAVITY = 0.2;
        const MAX_POWER = 150; // Increased for longer range
        const WIND_FACTOR = 0.03; // Increased for stronger wind effect
        const TERRAIN_SEGMENTS = 100;
        const CLOUD_COUNT = 8;
        const TICK_RATE = 16; // ~60fps
        const TURN_TIME = 30; // seconds
        
        // Game state
        let gameState = {
            screen: 'loading',
            playerId: null,
            playerName: '',
            roomId: null,
            isRoomOwner: false,
            isMyTurn: false,
            players: [],
            characters: [],
            mapOptions: [],
            weapons: null,
            items: null,
            terrain: [],
            platforms: [],
            projectiles: [],
            explosions: [],
            particles: [],
            powerups: [],
            angle: 45,
            power: 50,
            wind: 0,
            gravity: GRAVITY,
            windFactor: WIND_FACTOR,
            selectedWeapon: 'basic',
            inventory: {},
            clouds: [],
            camera: { x: 0, y: 0, targetX: 0, targetY: 0, scale: 1 },
            map: null,
            dragStart: null,
            lastFrameTime: 0,
            chatVisible: false,
            turnTimeRemaining: TURN_TIME,
            teleportMode: false,
            moveMode: false,
            moveDistance: 0
        };
        
        // Socket connection
        let socket = null;
        
        // DOM elements
        const loadingScreen = document.getElementById('loadingScreen');
        const menuScreen = document.getElementById('menuScreen');
        const roomScreen = document.getElementById('roomScreen');
        const waitingRoom = document.getElementById('waitingRoom');
        const gameCanvas = document.getElementById('gameCanvas');
        const uiCanvas = document.getElementById('uiCanvas');
        const gameUI = document.getElementById('gameUI');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const toast = document.getElementById('toast');
        const angleIndicator = document.getElementById('angleIndicator');
        const angleLine = document.getElementById('angleLine');
        const angleValue = document.getElementById('angleValue');
        const powerBarContainer = document.getElementById('powerBarContainer');
        const powerBar = document.getElementById('powerBar');
        const powerValue = document.getElementById('powerValue');
        const teleportOverlay = document.getElementById('teleportOverlay');
        const teleportCrosshair = document.getElementById('teleportCrosshair');
        const moveOverlay = document.getElementById('moveOverlay');
        const moveRange = document.getElementById('moveRange');
        
        // Game canvases and contexts
        const ctx = gameCanvas.getContext('2d');
        const uiCtx = uiCanvas.getContext('2d');
        
        // Set canvas resolution based on device pixel ratio
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = gameCanvas.getBoundingClientRect();
            
            gameCanvas.width = rect.width * dpr;
            gameCanvas.height = rect.height * dpr;
            uiCanvas.width = rect.width * dpr;
            uiCanvas.height = rect.height * dpr;
            
            ctx.scale(dpr, dpr);
            uiCtx.scale(dpr, dpr);
            
            gameCanvas.style.width = `${rect.width}px`;
            gameCanvas.style.height = `${rect.height}px`;
            uiCanvas.style.width = `${rect.width}px`;
            uiCanvas.style.height = `${rect.height}px`;
        }
        
        // Initialize the game
        function init() {
            setupCanvas();
            
            // Dark mode detection
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                if (event.matches) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });
            
            // Set up event listeners for UI elements
            setupEventListeners();
            
            // Setup websocket connection
            setupSocketConnection();
            
            // Start game loop
            requestAnimationFrame(gameLoop);
            
            // Load language
            setLanguage(currentLanguage);
            
            // Simulate loading complete
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                gameState.screen = 'menu';
            }, 1500);
        }
        
        // Generate map previews
        function createMapPreview(type, viName) {
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 60;
            const ctx = canvas.getContext('2d');
            
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 40);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F7FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 100, 60);
            
            // Draw terrain based on map type
            ctx.fillStyle = '#8B4513';
            
            switch(type) {
                case 'hills':
                    ctx.beginPath();
                    ctx.moveTo(0, 40);
                    ctx.bezierCurveTo(20, 35, 40, 45, 60, 40);
                    ctx.bezierCurveTo(80, 35, 90, 45, 100, 40);
                    ctx.lineTo(100, 60);
                    ctx.lineTo(0, 60);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'mountains':
                    ctx.beginPath();
                    ctx.moveTo(0, 50);
                    ctx.lineTo(20, 30);
                    ctx.lineTo(40, 45);
                    ctx.lineTo(60, 25);
                    ctx.lineTo(80, 40);
                    ctx.lineTo(100, 20);
                    ctx.lineTo(100, 60);
                    ctx.lineTo(0, 60);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'canyon':
                    ctx.beginPath();
                    ctx.moveTo(0, 35);
                    ctx.lineTo(30, 35);
                    ctx.lineTo(40, 55);
                    ctx.lineTo(60, 55);
                    ctx.lineTo(70, 35);
                    ctx.lineTo(100, 35);
                    ctx.lineTo(100, 60);
                    ctx.lineTo(0, 60);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'islands':
                    // First island
                    ctx.beginPath();
                    ctx.arc(30, 45, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Second island
                    ctx.beginPath();
                    ctx.arc(70, 40, 12, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'complex':
                    // Complex terrain with multiple islands and platforms
                    ctx.beginPath();
                    ctx.moveTo(0, 45);
                    ctx.lineTo(20, 35);
                    ctx.lineTo(30, 50);
                    ctx.lineTo(50, 30);
                    ctx.lineTo(70, 45);
                    ctx.lineTo(100, 35);
                    ctx.lineTo(100, 60);
                    ctx.lineTo(0, 60);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add some floating platforms
                    ctx.fillStyle = '#8D6E63';
                    ctx.fillRect(15, 20, 20, 5);
                    ctx.fillRect(60, 15, 25, 5);
                    ctx.fillRect(40, 30, 15, 5);
                    break;
            }
            
            // Add map name
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 100, 15);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(viName || type, 50, 7);
            
            return canvas.outerHTML;
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Menu buttons
            document.getElementById('createRoomBtn').addEventListener('click', createRoom);
            document.getElementById('joinRoomBtn').addEventListener('click', () => {
                gameState.screen = 'roomList';
                menuScreen.style.display = 'none';
                roomScreen.style.display = 'flex';
                fetchRooms();
            });
            
            // Room list buttons
            document.getElementById('refreshRoomsBtn').addEventListener('click', fetchRooms);
            document.getElementById('backToMenuBtn').addEventListener('click', () => {
                gameState.screen = 'menu';
                roomScreen.style.display = 'none';
                menuScreen.style.display = 'flex';
            });
            
            // Waiting room buttons
            document.getElementById('leaveRoomBtn').addEventListener('click', leaveRoom);
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            
            // Game over buttons
            document.getElementById('playAgainBtn').addEventListener('click', () => {
                gameOverScreen.style.display = 'none';
                waitingRoom.style.display = 'flex';
                gameUI.style.display = 'none';
                gameState.screen = 'waiting';
                socket.emit('ready-for-new-game');
            });
            
            document.getElementById('exitGameBtn').addEventListener('click', () => {
                gameOverScreen.style.display = 'none';
                menuScreen.style.display = 'flex';
                gameUI.style.display = 'none';
                gameState.screen = 'menu';
                socket.emit('leave-room');
                gameState.roomId = null;
                gameState.isRoomOwner = false;
            });
            
            // Game controls
            document.getElementById('angleUpBtn').addEventListener('click', () => {
                if (gameState.isMyTurn) {
                    gameState.angle = Math.min(180, gameState.angle + 5);
                    updateAngleUI();
                }
            });
            
            document.getElementById('angleDownBtn').addEventListener('click', () => {
                if (gameState.isMyTurn) {
                    gameState.angle = Math.max(0, gameState.angle - 5);
                    updateAngleUI();
                }
            });
            
            document.getElementById('powerUpBtn').addEventListener('click', () => {
                if (gameState.isMyTurn) {
                    gameState.power = Math.min(MAX_POWER, gameState.power + 5);
                    updatePowerUI();
                }
            });
            
            document.getElementById('powerDownBtn').addEventListener('click', () => {
                if (gameState.isMyTurn) {
                    gameState.power = Math.max(10, gameState.power - 5);
                    updatePowerUI();
                }
            });
            
            document.getElementById('fireBtn').addEventListener('click', () => {
                if (gameState.isMyTurn && !gameState.teleportMode && !gameState.moveMode) {
                    fireWeapon();
                }
            });
            
            document.getElementById('inventoryBtn').addEventListener('click', toggleInventory);
            document.getElementById('closeInventoryBtn').addEventListener('click', toggleInventory);
            
            document.getElementById('moveBtn').addEventListener('click', () => {
                if (gameState.isMyTurn && !gameState.teleportMode) {
                    toggleMoveMode();
                }
            });
            
            // Teleport/move mode handlers
            teleportOverlay.addEventListener('click', (e) => {
                if (gameState.teleportMode) {
                    const rect = gameCanvas.getBoundingClientRect();
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    
                    // Convert to world coordinates
                    const worldX = canvasX + gameState.camera.x - rect.width / 2;
                    const worldY = canvasY + gameState.camera.y - rect.height / 2;
                    
                    // Use teleport at target location
                    useTeleport(worldX, worldY);
                }
            });
            
            moveOverlay.addEventListener('click', (e) => {
                if (gameState.moveMode) {
                    const rect = gameCanvas.getBoundingClientRect();
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    
                    // Convert to world coordinates
                    const worldX = canvasX + gameState.camera.x - rect.width / 2;
                    const worldY = canvasY + gameState.camera.y - rect.height / 2;
                    
                    // Check if within move range
                    const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
                    
                    if (currentPlayer) {
                        const dx = worldX - currentPlayer.x;
                        const dy = worldY - currentPlayer.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance <= gameState.moveDistance) {
                            // Valid move location
                            movePlayer(worldX, worldY);
                        } else {
                            showToast(currentLanguage === 'vi' ? 'Quá xa! Di chuyển thất bại.' : 'Too far! Move failed.');
                        }
                    }
                }
            });
            
            // Chat controls
            document.getElementById('chatToggleBtn').addEventListener('click', toggleChat);
            document.getElementById('chatSendBtn').addEventListener('click', sendChatMessage);
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage();
                }
            });
            
            // Map dragging
            gameCanvas.addEventListener('mousedown', handleDragStart);
            gameCanvas.addEventListener('touchstart', handleDragStart, { passive: false });
            
            gameCanvas.addEventListener('mousemove', handleDragMove);
            gameCanvas.addEventListener('touchmove', handleDragMove, { passive: false });
            
            gameCanvas.addEventListener('mouseup', handleDragEnd);
            gameCanvas.addEventListener('touchend', handleDragEnd);
            
            // Update angle with mouse click
            gameCanvas.addEventListener('click', (e) => {
                if (gameState.isMyTurn && gameState.screen === 'game' && !gameState.teleportMode && !gameState.moveMode) {
                    const rect = gameCanvas.getBoundingClientRect();
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    
                    const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
                    if (currentPlayer) {
                        // Convert to world coordinates
                        const worldX = canvasX + gameState.camera.x - rect.width / 2;
                        const worldY = canvasY + gameState.camera.y - rect.height / 2;
                        
                        // Calculate angle
                        const dx = worldX - currentPlayer.x;
                        const dy = worldY - currentPlayer.y;
                        
                        let angle = Math.atan2(-dy, dx) * 180 / Math.PI;
                        if (angle < 0) angle += 360;
                        
                        // Set new angle
                        gameState.angle = angle;
                        updateAngleUI();
                    }
                }
            });
            
            // Mouse move to update teleport crosshair
            document.addEventListener('mousemove', (e) => {
                if (gameState.teleportMode || gameState.moveMode) {
                    teleportCrosshair.style.left = `${e.clientX - 15}px`;
                    teleportCrosshair.style.top = `${e.clientY - 15}px`;
                }
            });
            
            // Resize handler
            window.addEventListener('resize', () => {
                setupCanvas();
                positionAngleIndicator();
                positionPowerBar();
            });
        }
        
        // Socket connection setup with real Socket.io
        function setupSocketConnection() {
            // Connect to Socket.io server
            // When deploying to railway.app, the URL will be automatically adjusted
            const serverUrl = window.location.hostname === 'localhost' 
                ? 'http://localhost:3000' 
                : window.location.origin;
            
            socket = io(serverUrl);
            
            // Set up socket event handlers
            setupSocketEvents();
        }
        
        // Update the angle UI
        function updateAngleUI() {
            // Update angle line rotation
            const radians = gameState.angle * Math.PI / 180;
            angleLine.style.transform = `rotate(${-radians}rad)`;
            
            // Update angle value
            angleValue.textContent = `${Math.round(gameState.angle)}°`;
        }
        
        // Update the power UI
        function updatePowerUI() {
            // Update power bar width
            const powerPercent = (gameState.power / MAX_POWER) * 100;
            powerBar.style.width = `${powerPercent}%`;
            
            // Update power value
            powerValue.textContent = `${gameState.power}%`;
        }
        
        // Position angle indicator relative to current player
        function positionAngleIndicator() {
            if (gameState.screen !== 'game') return;
            
            const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
            if (!currentPlayer) return;
            
            const canvasWidth = gameCanvas.width / (window.devicePixelRatio || 1);
            const canvasHeight = gameCanvas.height / (window.devicePixelRatio || 1);
            
            // Calculate screen position
            const screenX = currentPlayer.x - gameState.camera.x + canvasWidth / 2;
            const screenY = currentPlayer.y - gameState.camera.y + canvasHeight / 2;
            
            // Position indicator at player
            angleIndicator.style.left = `${screenX - 60}px`;
            angleIndicator.style.top = `${screenY - 60}px`;
        }
        
        // Position power bar
        function positionPowerBar() {
            if (gameState.screen !== 'game') return;
            
            const canvasWidth = gameCanvas.width / (window.devicePixelRatio || 1);
            const canvasHeight = gameCanvas.height / (window.devicePixelRatio || 1);
            
            // Position power bar at bottom center
            powerBarContainer.style.left = `${canvasWidth / 2 - 75}px`;
            powerBarContainer.style.bottom = `80px`;
        }
        
        // Create a new game room
        function createRoom() {
            const playerNameInput = document.getElementById('playerName');
            const playerName = playerNameInput.value.trim() || `Player${Math.floor(Math.random() * 1000)}`;
            
            if (playerName.length < 3) {
                showToast(currentLanguage === 'vi' ? 'Tên phải có ít nhất 3 ký tự' : 'Name must be at least 3 characters');
                return;
            }
            
            gameState.playerName = playerName;
            
            socket.emit('create-room', { 
                playerName: playerName,
                character: gameState.selectedCharacter || 'gunman'
            }, (response) => {
                if (response.success) {
                    gameState.roomId = response.roomId;
                    gameState.isRoomOwner = true;
                    gameState.players = response.players;
                    gameState.characters = response.characters || [];
                    gameState.mapOptions = response.mapOptions || [];
                    
                    document.getElementById('roomCodeValue').textContent = response.roomId;
                    document.getElementById('startGameBtn').style.display = 'block';
                    document.getElementById('mapSelectionContainer').style.display = 'block';
                    
                    // Create character selection
                    createCharacterSelection();
                    
                    // Create map selection
                    createMapSelection();
                    
                    updateWaitingRoomPlayers();
                    
                    menuScreen.style.display = 'none';
                    waitingRoom.style.display = 'flex';
                    gameState.screen = 'waiting';
                } else {
                    showToast(currentLanguage === 'vi' ? 'Không thể tạo phòng: ' + response.message : 'Failed to create room: ' + response.message);
                }
            });
        }
        
        // Create character selection UI
        function createCharacterSelection() {
            const characterSelection = document.querySelector('.character-selection');
            characterSelection.innerHTML = ''; // Clear existing options
            
            if (!gameState.characters || gameState.characters.length === 0) {
                return;
            }
            
            gameState.characters.forEach(char => {
                const charElement = document.createElement('div');
                charElement.className = `character-option ${char.id === (gameState.selectedCharacter || 'gunman') ? 'selected' : ''}`;
                charElement.dataset.characterId = char.id;
                
                // Character preview with color and icon
                charElement.innerHTML = `
                    <div class="character-preview" style="background-color: ${char.color}">${char.icon}</div>
                    <div class="character-name">${currentLanguage === 'vi' ? char.viName : char.name}</div>
                    <div class="character-stats">
                        <div>${currentLanguage === 'vi' ? 'Máu' : 'Health'}: ${char.maxHealth}</div>
                        <div>${currentLanguage === 'vi' ? 'Sát thương' : 'Damage'}: x${char.damageMultiplier}</div>
                        <div>${currentLanguage === 'vi' ? 'Di chuyển' : 'Speed'}: ${char.moveSpeed}</div>
                        <div>${currentLanguage === 'vi' ? 'Mô tả' : 'Description'}: ${char.description}</div>
                    </div>
                `;
                
                charElement.addEventListener('click', () => {
                    document.querySelectorAll('.character-option').forEach(el => {
                        el.classList.remove('selected');
                    });
                    charElement.classList.add('selected');
                    gameState.selectedCharacter = char.id;
                });
                
                characterSelection.appendChild(charElement);
            });
            
            // Default to first character if none selected
            if (!gameState.selectedCharacter) {
                gameState.selectedCharacter = gameState.characters[0].id;
            }
        }
        
        // Create map selection UI
        function createMapSelection() {
            const mapSelectionList = document.getElementById('mapSelectionList');
            mapSelectionList.innerHTML = ''; // Clear existing options
            
            if (!gameState.mapOptions || gameState.mapOptions.length === 0) {
                return;
            }
            
            gameState.mapOptions.forEach((map, index) => {
                const mapElement = document.createElement('div');
                mapElement.className = `map-option ${index === 0 ? 'selected' : ''}`;
                mapElement.dataset.mapId = map.id;
                
                // Create map preview and name
                mapElement.innerHTML = `
                    <div class="map-preview">${createMapPreview(map.id, map.viName)}</div>
                    <div class="map-name">${currentLanguage === 'vi' ? map.viName : map.name}</div>
                `;
                
                mapElement.addEventListener('click', () => {
                    document.querySelectorAll('.map-option').forEach(el => {
                        el.classList.remove('selected');
                    });
                    mapElement.classList.add('selected');
                    gameState.map = map.id;
                });
                
                mapSelectionList.appendChild(mapElement);
            });
            
            // Default to first map
            gameState.map = gameState.mapOptions[0].id;
        }
        
        // Fetch available rooms
        function fetchRooms() {
            document.getElementById('roomsList').innerHTML = `<p class="text-center text-white" data-lang="loading-rooms">${currentLanguage === 'vi' ? 'Đang tải danh sách phòng...' : 'Loading rooms...'}</p>`;
            
            socket.emit('get-rooms', (response) => {
                if (response.success) {
                    const roomsList = document.getElementById('roomsList');
                    
                    if (response.rooms.length === 0) {
                        roomsList.innerHTML = `<p class="text-center text-white" data-lang="no-rooms">${currentLanguage === 'vi' ? 'Không có phòng nào. Hãy tạo phòng mới!' : 'No rooms available. Create a new one!'}</p>`;
                        return;
                    }
                    
                    roomsList.innerHTML = '';
                    
                    response.rooms.forEach(room => {
                        const roomItem = document.createElement('div');
                        roomItem.className = 'room-item';
                        roomItem.innerHTML = `
                            <div>
                                <div class="room-name">${room.name || (currentLanguage === 'vi' ? 'Phòng Chơi' : 'Game Room')}</div>
                                <div class="room-info">${currentLanguage === 'vi' ? 'Người chơi' : 'Players'}: ${room.players}/${room.maxPlayers}</div>
                            </div>
                            <button class="menu-btn w-auto px-4 py-2 text-sm" data-lang="join-room">${currentLanguage === 'vi' ? 'Tham Gia' : 'Join'}</button>
                        `;
                        
                        roomItem.querySelector('button').addEventListener('click', () => {
                            joinRoom(room.id);
                        });
                        
                        roomsList.appendChild(roomItem);
                    });
                } else {
                    showToast(currentLanguage === 'vi' ? 'Không thể tải danh sách phòng: ' + response.message : 'Failed to fetch rooms: ' + response.message);
                }
            });
        }
        
        // Join an existing room
        function joinRoom(roomId) {
            const playerNameInput = document.getElementById('playerName');
            const playerName = playerNameInput.value.trim() || `Player${Math.floor(Math.random() * 1000)}`;
            
            if (playerName.length < 3) {
                showToast(currentLanguage === 'vi' ? 'Tên phải có ít nhất 3 ký tự' : 'Name must be at least 3 characters');
                return;
            }
            
            gameState.playerName = playerName;
            
            socket.emit('join-room', {
                roomId: roomId,
                playerName: playerName,
                character: gameState.selectedCharacter || 'gunman'
            }, (response) => {
                if (response.success) {
                    gameState.roomId = response.roomId;
                    gameState.isRoomOwner = false;
                    gameState.players = response.players;
                    gameState.characters = response.characters || [];
                    gameState.mapOptions = response.mapOptions || [];
                    
                    document.getElementById('roomCodeValue').textContent = response.roomId;
                    document.getElementById('startGameBtn').style.display = 'none';
                    document.getElementById('mapSelectionContainer').style.display = 'none';
                    
                    // Create character selection
                    createCharacterSelection();
                    
                    updateWaitingRoomPlayers();
                    
                    roomScreen.style.display = 'none';
                    waitingRoom.style.display = 'flex';
                    gameState.screen = 'waiting';
                } else {
                    showToast(currentLanguage === 'vi' ? 'Không thể tham gia phòng: ' + response.message : 'Failed to join room: ' + response.message);
                }
            });
        }
        
        // Leave the current room
        function leaveRoom() {
            socket.emit('leave-room');
            
            waitingRoom.style.display = 'none';
            menuScreen.style.display = 'flex';
            gameState.screen = 'menu';
            gameState.roomId = null;
            gameState.isRoomOwner = false;
        }
        
        // Start the game
        function startGame() {
            if (!gameState.isRoomOwner) return;
            
            // Get selected map
            const selectedMapEl = document.querySelector('.map-option.selected');
            if (selectedMapEl) {
                gameState.map = selectedMapEl.dataset.mapId;
            }
            
            socket.emit('start-game', { mapId: gameState.map });
        }
        
        // Update player list in waiting room
        function updateWaitingRoomPlayers() {
            const waitingPlayersList = document.getElementById('waitingPlayersList');
            waitingPlayersList.innerHTML = '';
            
            gameState.players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                
                const character = gameState.characters.find(c => c.id === player.character);
                
                if (!character) return;
                
                playerCard.innerHTML = `
                    <div class="player-avatar" style="background-color: ${character.color}">${character.icon}</div>
                    <div class="player-name">${player.name}</div>
                    <div class="player-status">${player.isOwner ? (currentLanguage === 'vi' ? 'Chủ phòng' : 'Room Owner') : (currentLanguage === 'vi' ? 'Người chơi' : 'Player')}</div>
                `;
                
                waitingPlayersList.appendChild(playerCard);
            });
        }
        
        // Fire the current weapon
        function fireWeapon() {
            if (!gameState.isMyTurn) return;
            
            const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
            if (!currentPlayer) return;
            
            const weapon = currentPlayer.inventory[gameState.selectedWeapon];
            
            // Check if we have ammo for this weapon
            if (weapon.ammo === 0) {
                showToast(currentLanguage === 'vi' ? 'Hết đạn cho vũ khí này!' : 'Out of ammo for this weapon!');
                return;
            }
            
            // Decrease ammo if limited
            if (weapon.ammo > 0) {
                weapon.ammo--;
            }
            
            // Disable controls during firing
            gameState.isMyTurn = false;
            document.getElementById('turnText').textContent = currentLanguage === 'vi' ? 'Đang bắn...' : 'Firing...';
            
            // Calculate initial velocity based on angle and power
            const angleRad = gameState.angle * Math.PI / 180;
            const power = gameState.power / 100 * 20; // Scale power to a reasonable velocity
            
            // Determine facing direction based on angle
            const facingLeft = gameState.angle > 90 && gameState.angle < 270;
            
            const velocityX = Math.cos(angleRad) * power;
            const velocityY = -Math.sin(angleRad) * power;
            
            // Create projectile
            const projectile = {
                id: 'proj-' + Date.now(),
                x: currentPlayer.x + (facingLeft ? -20 : 20),
                y: currentPlayer.y - 10,
                velocityX: velocityX,
                velocityY: velocityY,
                type: gameState.selectedWeapon,
                ownerId: currentPlayer.id,
                gravity: gameState.gravity,
                wind: gameState.wind,
                trailParticles: []
            };
            
            gameState.projectiles.push(projectile);
            
            // Set camera to follow projectile
            gameState.camera.targetX = projectile.x;
            gameState.camera.targetY = projectile.y;
            
            // Tell server about the fired projectile
            socket.emit('fire', {
                projectile: projectile,
                weapon: gameState.selectedWeapon
            });
            
            // Update inventory UI
            populateInventory();
        }
        
        // Toggle inventory panel
        function toggleInventory() {
            const inventoryPanel = document.getElementById('inventoryPanel');
            inventoryPanel.classList.toggle('show');
        }
        
        // Toggle move mode
        function toggleMoveMode() {
            gameState.moveMode = !gameState.moveMode;
            
            // Update UI
            moveOverlay.style.display = gameState.moveMode ? 'block' : 'none';
            teleportCrosshair.style.display = gameState.moveMode ? 'block' : 'none';
            
            if (gameState.moveMode) {
                // Get current player's move distance
                const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
                if (currentPlayer) {
                    const character = gameState.characters.find(c => c.id === currentPlayer.character);
                    if (character) {
                        gameState.moveDistance = character.moveSpeed * 20; // Scale based on character speed
                        
                        // Set move range circle
                        moveRange.style.width = `${gameState.moveDistance * 2}px`;
                        moveRange.style.height = `${gameState.moveDistance * 2}px`;
                        
                        // Position move range around player
                        const canvasWidth = gameCanvas.width / (window.devicePixelRatio || 1);
                        const canvasHeight = gameCanvas.height / (window.devicePixelRatio || 1);
                        
                        const screenX = currentPlayer.x - gameState.camera.x + canvasWidth / 2;
                        const screenY = currentPlayer.y - gameState.camera.y + canvasHeight / 2;
                        
                        moveRange.style.left = `${screenX - gameState.moveDistance}px`;
                        moveRange.style.top = `${screenY - gameState.moveDistance}px`;
                    }
                }
            }
        }
        
        // Move player to new position
        function movePlayer(x, y) {
            // Find terrain height at new x position
            let terrainY = 1500; // Default bottom
            
            if (gameState.terrain && gameState.terrain.length > 0) {
                const segmentWidth = 3000 / TERRAIN_SEGMENTS;
                const index = Math.floor(x / segmentWidth);
                
                if (index >= 0 && index < gameState.terrain.length - 1) {
                    const p1 = gameState.terrain[index];
                    const p2 = gameState.terrain[index + 1];
                    
                    // Interpolate height at x
                    const t = (x - p1.x) / (p2.x - p1.x);
                    terrainY = p1.y + t * (p2.y - p1.y);
                }
            }
            
            // Check platforms
            for (const platform of gameState.platforms) {
                if (x >= platform.x && x <= platform.x + platform.width && y <= platform.y) {
                    terrainY = Math.min(terrainY, platform.y);
                }
            }
            
            // Position player just above terrain/platform
            const newY = terrainY - 40;
            
            // Send movement to server
            socket.emit('move-player', {
                x: x,
                y: newY
            });
            
            // Update local player position
            const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
            if (currentPlayer) {
                currentPlayer.x = x;
                currentPlayer.y = newY;
            }
            
            // Position angle indicator at new position
            positionAngleIndicator();
            
            // Exit move mode
            gameState.moveMode = false;
            moveOverlay.style.display = 'none';
            teleportCrosshair.style.display = 'none';
            
            // End turn
            socket.emit('turn-complete');
        }
        
        // Toggle teleport mode and UI
        function toggleTeleportMode() {
            gameState.teleportMode = !gameState.teleportMode;
            
            // Update UI
            teleportOverlay.style.display = gameState.teleportMode ? 'block' : 'none';
            teleportCrosshair.style.display = gameState.teleportMode ? 'block' : 'none';
        }
        
        // Use teleport to position
        function useTeleport(x, y) {
            // Find terrain height at new x position
            let terrainY = 1500; // Default bottom
            
            if (gameState.terrain && gameState.terrain.length > 0) {
                const segmentWidth = 3000 / TERRAIN_SEGMENTS;
                const index = Math.floor(x / segmentWidth);
                
                if (index >= 0 && index < gameState.terrain.length - 1) {
                    const p1 = gameState.terrain[index];
                    const p2 = gameState.terrain[index + 1];
                    
                    // Interpolate height at x
                    const t = (x - p1.x) / (p2.x - p1.x);
                    terrainY = p1.y + t * (p2.y - p1.y);
                }
            }
            
            // Check platforms
            for (const platform of gameState.platforms) {
                if (x >= platform.x && x <= platform.x + platform.width && y <= platform.y) {
                    terrainY = Math.min(terrainY, platform.y);
                }
            }
            
            // Position player just above terrain/platform
            const newY = terrainY - 40;
            
            // Use teleport item
            socket.emit('use-item', {
                itemId: 'teleport',
                targetX: x,
                targetY: newY
            });
            
            // Update local player position
            const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
            if (currentPlayer) {
                currentPlayer.x = x;
                currentPlayer.y = newY;
                
                // Reduce teleport count
                if (currentPlayer.inventory.teleport) {
                    currentPlayer.inventory.teleport.ammo--;
                }
            }
            
            // Create teleport effect particles
            gameState.particles.push(...createTeleportEffect(x, newY));
            
            // Position angle indicator at new position
            positionAngleIndicator();
            
            // Exit teleport mode
            gameState.teleportMode = false;
            teleportOverlay.style.display = 'none';
            teleportCrosshair.style.display = 'none';
            
            // Update inventory
            populateInventory();
            
            // End turn
            socket.emit('turn-complete');
        }
        
        // Create teleport effect particles
        function createTeleportEffect(x, y) {
            const particles = [];
            
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 5;
                
                particles.push({
                    x: x,
                    y: y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    size: 5 + Math.random() * 10,
                    color: '#9C27B0',
                    opacity: 1,
                    life: 30 + Math.random() * 30
                });
            }
            
            return particles;
        }
        
        // Populate inventory with weapons and items
        function populateInventory() {
            const inventoryGrid = document.getElementById('inventoryGrid');
            inventoryGrid.innerHTML = '';
            
            const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
            if (!currentPlayer || !currentPlayer.inventory) return;
            
            Object.entries(currentPlayer.inventory).forEach(([id, item]) => {
                const inventoryItem = document.createElement('div');
                inventoryItem.className = `inventory-item ${id === gameState.selectedWeapon ? 'selected' : ''}`;
                inventoryItem.dataset.itemId = id;
                
                // Display infinite ammo as ∞
                const ammoDisplay = item.ammo < 0 ? '∞' : item.ammo;
                
                inventoryItem.innerHTML = `
                    <div class="inventory-icon">${item.icon}</div>
                    <div class="inventory-name">${currentLanguage === 'vi' ? item.viName : item.name}</div>
                    <div class="text-xs">${ammoDisplay}</div>
                `;
                
                inventoryItem.addEventListener('click', () => {
                    if (item.type === 'weapon' && gameState.isMyTurn) {
                        document.querySelectorAll('.inventory-item').forEach(el => {
                            el.classList.remove('selected');
                        });
                        inventoryItem.classList.add('selected');
                        gameState.selectedWeapon = id;
                        document.getElementById('weaponName').textContent = currentLanguage === 'vi' ? item.viName : item.name;
                        inventoryPanel.classList.remove('show');
                    } else if (item.type === 'item' && gameState.isMyTurn && item.ammo > 0) {
                        useItem(id);
                        inventoryPanel.classList.remove('show');
                    }
                });
                
                inventoryGrid.appendChild(inventoryItem);
            });
        }
        
        // Use an inventory item
        function useItem(itemId) {
            const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
            if (!currentPlayer || !currentPlayer.inventory[itemId]) return;
            
            const item = currentPlayer.inventory[itemId];
            if (item.ammo <= 0) return;
            
            switch (itemId) {
                case 'healthpack':
                    // Heal player
                    socket.emit('use-item', {
                        itemId: 'healthpack'
                    });
                    
                    // Add healing effect
                    gameState.particles.push(...createHealingEffect(currentPlayer.x, currentPlayer.y));
                    
                    // Update local player health
                    currentPlayer.health = Math.min(currentPlayer.maxHealth, currentPlayer.health + 30);
                    
                    // Decrease item count
                    item.ammo--;
                    
                    // Show toast
                    showToast('+30 ' + (currentLanguage === 'vi' ? 'Máu' : 'Health'));
                    
                    // End turn
                    socket.emit('turn-complete');
                    break;
                    
                case 'shield':
                    // Apply shield
                    socket.emit('use-item', {
                        itemId: 'shield'
                    });
                    
                    // Add shield effect locally
                    currentPlayer.effects.push({
                        type: 'shield',
                        duration: 2,
                        value: 0.5
                    });
                    
                    // Add shield visual effect
                    gameState.particles.push(...createShieldEffect(currentPlayer.x, currentPlayer.y));
                    
                    // Decrease item count
                    item.ammo--;
                    
                    // Show toast
                    showToast(currentLanguage === 'vi' ? 'Đã kích hoạt khiên' : 'Shield Activated');
                    
                    // End turn
                    socket.emit('turn-complete');
                    break;
                    
                case 'teleport':
                    // Enter teleport mode
                    toggleTeleportMode();
                    break;
            }
            
            // Update inventory UI
            populateInventory();
        }
        
        // Create healing effect particles
        function createHealingEffect(x, y) {
            const particles = [];
            
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x + (Math.random() * 40 - 20),
                    y: y + (Math.random() * 40 - 20),
                    velocityX: (Math.random() - 0.5) * 2,
                    velocityY: -Math.random() * 3,
                    size: 5 + Math.random() * 10,
                    color: '#4CAF50',
                    opacity: 1,
                    life: 30 + Math.random() * 30
                });
            }
            
            return particles;
        }
        
        // Create shield effect particles
        function createShieldEffect(x, y) {
            const particles = [];
            
            for (let i = 0; i < 30; i++) {
                const angle = i / 30 * Math.PI * 2;
                const distance = 40;
                
                particles.push({
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    velocityX: Math.cos(angle) * 0.5,
                    velocityY: Math.sin(angle) * 0.5,
                    size: 8,
                    color: '#64B5F6',
                    opacity: 1,
                    life: 60 + Math.random() * 20
                });
            }
            
            return particles;
        }
        
        // Toggle chat visibility
        function toggleChat() {
            const chatContainer = document.getElementById('chatContainer');
            chatContainer.classList.toggle('show');
            gameState.chatVisible = chatContainer.classList.contains('show');
            
            if (gameState.chatVisible) {
                document.getElementById('chatInput').focus();
            }
        }
        
        // Send a chat message
        function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (message) {
                socket.emit('chat-message', {
                    sender: gameState.playerName,
                    message: message
                });
                
                chatInput.value = '';
            }
        }
        
        // Add a message to the chat
        function addChatMessage(sender, message, isSystem = false) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            
            messageElement.className = isSystem ? 'chat-message system-message' : 'chat-message';
            
            if (isSystem) {
                messageElement.textContent = message;
            } else {
                messageElement.innerHTML = `<span class="chat-name">${sender}:</span> ${message}`;
            }
            
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // Handle drag start (for map movement)
        function handleDragStart(e) {
            e.preventDefault();
            
            if (gameState.teleportMode || gameState.moveMode) return;
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            if (clientX && clientY) {
                gameState.dragStart = {
                    x: clientX,
                    y: clientY,
                    cameraX: gameState.camera.x,
                    cameraY: gameState.camera.y
                };
            }
        }
        
        // Handle drag move
        function handleDragMove(e) {
            e.preventDefault();
            
            if (!gameState.dragStart || gameState.teleportMode || gameState.moveMode) return;
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            if (clientX && clientY) {
                const dx = (clientX - gameState.dragStart.x) * 2;
                const dy = (clientY - gameState.dragStart.y) * 2;
                
                gameState.camera.x = gameState.dragStart.cameraX - dx;
                gameState.camera.y = gameState.dragStart.cameraY - dy;
                
                // Update target position as well to prevent snap-back
                gameState.camera.targetX = gameState.camera.x;
                gameState.camera.targetY = gameState.camera.y;
                
                // Update angle indicator and power bar position
                positionAngleIndicator();
                positionPowerBar();
                
                // Update move range if in move mode
                if (gameState.moveMode) {
                    const currentPlayer = gameState.players.find(p => p.id === gameState.playerId);
                    if (currentPlayer) {
                        const canvasWidth = gameCanvas.width / (window.devicePixelRatio || 1);
                        const canvasHeight = gameCanvas.height / (window.devicePixelRatio || 1);
                        
                        const screenX = currentPlayer.x - gameState.camera.x + canvasWidth / 2;
                        const screenY = currentPlayer.y - gameState.camera.y + canvasHeight / 2;
                        
                        moveRange.style.left = `${screenX - gameState.moveDistance}px`;
                        moveRange.style.top = `${screenY - gameState.moveDistance}px`;
                    }
                }
            }
        }
        
        // Handle drag end
        function handleDragEnd() {
            gameState.dragStart = null;
        }
        
        // Show a toast notification
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }
        
        // Main game loop
        function gameLoop(timestamp) {
            const deltaTime = timestamp - gameState.lastFrameTime;
            gameState.lastFrameTime = timestamp;
            
            // Update game state
            update(deltaTime);
            
            // Render game
            render();
            
            // Request next frame
            requestAnimationFrame(gameLoop);
        }
        
        // Update game state
        function update(deltaTime) {
            if (gameState.screen !== 'game') return;
            
            // Update camera position smoothly
            const cameraSpeed = 0.1;
            gameState.camera.x += (gameState.camera.targetX - gameState.camera.x) * cameraSpeed;
            gameState.camera.y += (gameState.camera.targetY - gameState.camera.y) * cameraSpeed;
            
            // Update angle indicator and power bar position
            positionAngleIndicator();
            positionPowerBar();
            
            // Update projectiles
            updateProjectiles();
            
            // Update explosions
            updateExplosions();
            
            // Update particles
            updateParticles(deltaTime);
            
            // Update clouds
            updateClouds();
        }
        
        // Update projectiles
        function updateProjectiles() {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                
                // Apply gravity
                proj.velocityY += proj.gravity;
                
                // Apply wind (stronger effect)
                proj.velocityX += parseFloat(proj.wind) * gameState.windFactor;
                
                // Update position
                proj.x += proj.velocityX;
                proj.y += proj.velocityY;
                
                // Add trail particles
                if (Math.random() > 0.5) {
                    gameState.particles.push({
                        x: proj.x,
                        y: proj.y,
                        velocityX: (Math.random() - 0.5) * 2,
                        velocityY: (Math.random() - 0.5) * 2,
                        size: 4,
                        color: getProjectileColor(proj.type),
                        opacity: 0.7,
                        life: 20
                    });
                }
                
                // Check for collisions with terrain or platforms
                if (checkProjectileCollision(proj)) {
                    createExplosion(proj);
                    gameState.projectiles.splice(i, 1);
                    continue;
                }
                
                // Check if out of bounds
                if (proj.x < 0 || proj.x > 3000 || proj.y > 1500) {
                    gameState.projectiles.splice(i, 1);
                    
                    // End turn if all projectiles are gone
                    if (gameState.projectiles.length === 0) {
                        endTurn();
                    }
                }
                
                // Update camera to follow projectile
                gameState.camera.targetX = proj.x;
                gameState.camera.targetY = proj.y;
            }
        }
        
        // Check if a projectile collides with terrain or players
        function checkProjectileCollision(projectile) {
            // Check collision with terrain
            const terrainCollision = checkTerrainCollision(projectile.x, projectile.y);
            if (terrainCollision) return true;
            
            // Check collision with platforms
            for (const platform of gameState.platforms) {
                if (projectile.x >= platform.x && 
                    projectile.x <= platform.x + platform.width &&
                    projectile.y >= platform.y && 
                    projectile.y <= platform.y + platform.height) {
                    return true;
                }
            }
            
            // Check collision with players
            for (const player of gameState.players) {
                if (!player.alive || player.id === projectile.ownerId) continue;
                
                const dx = projectile.x - player.x;
                const dy = projectile.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 30) { // Player hitbox radius
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if a point collides with terrain
        function checkTerrainCollision(x, y) {
            if (!gameState.terrain || gameState.terrain.length === 0) return false;
            
            const terrain = gameState.terrain;
            const segmentWidth = 3000 / TERRAIN_SEGMENTS;
            
            // Find the two terrain points surrounding x
            const index = Math.floor(x / segmentWidth);
            
            if (index < 0 || index >= terrain.length - 1) return false;
            
            const p1 = terrain[index];
            const p2 = terrain[index + 1];
            
            // Interpolate height at x
            const t = (x - p1.x) / (p2.x - p1.x);
            const terrainHeight = p1.y + t * (p2.y - p1.y);
            
            // Check if y is below terrain height
            return y >= terrainHeight;
        }
        
        // Get color for projectile trail based on weapon type
        function getProjectileColor(type) {
            if (gameState.weapons && gameState.weapons[type]) {
                return gameState.weapons[type].color;
            }
            
            // Fallback colors if weapons not loaded
            switch (type) {
                case 'basic': return '#FF9800';
                case 'missile': return '#F44336';
                case 'laser': return '#00BCD4';
                case 'tornado': return '#03A9F4';
                case 'shotgun': return '#795548';
                case 'axe': return '#E91E63';
                case 'vine': return '#4CAF50';
                case 'egg': return '#FFEB3B';
                default: return '#FFFFFF';
            }
        }
        
        // Create an explosion
        function createExplosion(projectile) {
            let radius, damage, particleCount, color;
            
            // Get weapon properties from server data if available
            if (gameState.weapons && gameState.weapons[projectile.type]) {
                const weapon = gameState.weapons[projectile.type];
                radius = weapon.radius;
                damage = weapon.damage;
                particleCount = weapon.particleCount;
                color = weapon.color;
            } else {
                // Default values if weapon data not available
                radius = 80;
                damage = 25;
                particleCount = 30;
                color = getProjectileColor(projectile.type);
            }
            
            // Special weapon effects
            switch (projectile.type) {
                case 'cluster':
                case 'shotgun':
                    // Create multiple smaller explosions
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const offsetX = (Math.random() - 0.5) * 100;
                            const offsetY = (Math.random() - 0.5) * 100;
                            
                            gameState.explosions.push({
                                x: projectile.x + offsetX,
                                y: projectile.y + offsetY,
                                radius: 40,
                                damage: 10,
                                currentRadius: 0,
                                maxRadius: 40,
                                expandSpeed: 3,
                                life: 20,
                                color: color
                            });
                            
                            // Create particles for secondary explosions
                            gameState.particles.push(...createExplosionParticles(
                                projectile.x + offsetX, 
                                projectile.y + offsetY, 
                                15, 
                                color
                            ));
                            
                            // Damage players in secondary explosion radius
                            damagePlayersInRadius(
                                projectile.x + offsetX, 
                                projectile.y + offsetY, 
                                40, 
                                10, 
                                projectile.ownerId
                            );
                        }, 300 + i * 200);
                    }
                    break;
                    
                case 'egg':
                    // Egg-specific effect: drop additional explosions downward
                    for (let i = 0; i < 2; i++) {
                        setTimeout(() => {
                            const offsetX = (Math.random() - 0.5) * 40;
                            const offsetY = (i + 1) * 60; // Drop downward
                            
                            gameState.explosions.push({
                                x: projectile.x + offsetX,
                                y: projectile.y + offsetY,
                                radius: 50,
                                damage: 15,
                                currentRadius: 0,
                                maxRadius: 50,
                                expandSpeed: 3,
                                life: 20,
                                color: color
                            });
                            
                            // Create particles for egg explosions
                            gameState.particles.push(...createExplosionParticles(
                                projectile.x + offsetX, 
                                projectile.y + offsetY, 
                                20, 
                                '#FFEB3B'
                            ));
                            
                            // Damage players in egg explosion radius
                            damagePlayersInRadius(
                                projectile.x + offsetX, 
                                projectile.y + offsetY, 
                                50, 
                                15, 
                                projectile.ownerId
                            );
                        }, 400 + i * 300);
                    }
                    break;
            }
            
            // Create main explosion
            gameState.explosions.push({
                x: projectile.x,
                y: projectile.y,
                radius: radius,
                damage: damage,
                currentRadius: 0,
                maxRadius: radius,
                expandSpeed: 4,
                life: 30,
                color: color
            });
            
            // Create particles
            gameState.particles.push(...createExplosionParticles(
                projectile.x, 
                projectile.y, 
                particleCount, 
                color
            ));
            
            // Damage players in radius
            damagePlayersInRadius(projectile.x, projectile.y, radius, damage, projectile.ownerId);
            
            // Modify terrain for certain weapons that should affect terrain
            if (['basic', 'missile', 'grenade', 'axe'].includes(projectile.type)) {
                modifyTerrain(projectile.x, projectile.y, radius * 0.8);
            }
        }
        
        // Create explosion particles
        function createExplosionParticles(x, y, count, color) {
            const particles = [];
            
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 5;
                
                particles.push({
                    x: x,
                    y: y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    size: 5 + Math.random() * 10,
                    color: color || '#FF9800',
                    opacity: 1,
                    life: 30 + Math.random() * 30
                });
            }
            
            return particles;
        }
        
        // Damage players in explosion radius
        function damagePlayersInRadius(x, y, radius, baseDamage, attackerId) {
            for (const player of gameState.players) {
                if (!player.alive) continue;
                
                const dx = player.x - x;
                const dy = player.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < radius) {
                    // Calculate damage based on distance (more damage closer to center)
                    const distanceFactor = 1 - (distance / radius);
                    let damage = Math.round(baseDamage * distanceFactor);
                    
                    // Apply attacker's damage multiplier
                    const attacker = gameState.players.find(p => p.id === attackerId);
                    if (attacker) {
                        damage = Math.round(damage * attacker.damageMultiplier);
                    }
                    
                    // Apply shield effect if present
                    const shieldEffect = player.effects.find(e => e.type === 'shield');
                    if (shieldEffect) {
                        damage = Math.round(damage * (1 - shieldEffect.value));
                        
                        // Create shield hit effect
                        gameState.particles.push(...createShieldHitEffect(player.x, player.y));
                    }
                    
                    // Update server about damage
                    socket.emit('damage-player', {
                        targetId: player.id,
                        attackerId: attackerId,
                        damage: damage
                    });
                    
                    // Apply damage locally
                    player.health = Math.max(0, player.health - damage);
                    
                    // Check if player is dead
                    if (player.health <= 0 && player.alive) {
                        player.alive = false;
                        
                        // Create death effect
                        gameState.particles.push(...createDeathEffect(player.x, player.y));
                    }
                    
                    // Create hit number indicator
                    createDamageNumber(player.x, player.y - 20, damage);
                }
            }
        }
        
        // Create shield hit effect
        function createShieldHitEffect(x, y) {
            const particles = [];
            
            for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                
                particles.push({
                    x: x + Math.cos(angle) * 30,
                    y: y + Math.sin(angle) * 30,
                    velocityX: Math.cos(angle) * 2,
                    velocityY: Math.sin(angle) * 2,
                    size: 10,
                    color: '#64B5F6',
                    opacity: 1,
                    life: 20 + Math.random() * 10
                });
            }
            
            return particles;
        }
        
        // Create death effect particles
        function createDeathEffect(x, y) {
            const particles = [];
            
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 5;
                
                particles.push({
                    x: x,
                    y: y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    size: 8 + Math.random() * 8,
                    color: '#F44336',
                    opacity: 1,
                    life: 60 + Math.random() * 60
                });
            }
            
            return particles;
        }
        
        // Create floating damage number
        function createDamageNumber(x, y, damage) {
            gameState.particles.push({
                x: x,
                y: y,
                velocityX: 0,
                velocityY: -1,
                text: `-${damage}`,
                color: '#F44336',
                opacity: 1,
                life: 60,
                type: 'text'
            });
        }
        
        // Modify terrain at explosion point
        function modifyTerrain(x, y, radius) {
            if (!gameState.terrain || gameState.terrain.length === 0) return;
            
            const terrain = gameState.terrain;
            const segmentWidth = 3000 / TERRAIN_SEGMENTS;
            
            // Find affected segments
            const startIndex = Math.max(0, Math.floor((x - radius) / segmentWidth));
            const endIndex = Math.min(terrain.length - 1, Math.floor((x + radius) / segmentWidth));
            
            // Modify terrain heights
            let modified = false;
            
            for (let i = startIndex; i <= endIndex; i++) {
                const point = terrain[i];
                const dx = point.x - x;
                const distance = Math.abs(dx);
                
                if (distance < radius) {
                    // Calculate depth based on distance from center (deeper at center)
                    const depthFactor = (radius - distance) / radius;
                    const maxDepth = 50; // Maximum terrain deformation
                    
                    // Only deform if explosion is close to or below terrain
                    if (y + 20 > point.y) {
                        // Create a crater effect
                        point.y += maxDepth * depthFactor;
                        modified = true;
                    }
                }
            }
            
            // If terrain was modified, tell the server
            if (modified) {
                socket.emit('modify-terrain', {
                    terrain: terrain
                });
            }
        }
        
        // Update explosions
        function updateExplosions() {
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                
                // Expand the explosion
                if (explosion.currentRadius < explosion.maxRadius) {
                    explosion.currentRadius += explosion.expandSpeed;
                }
                
                // Decrease life
                explosion.life--;
                
                // Remove expired explosions
                if (explosion.life <= 0) {
                    gameState.explosions.splice(i, 1);
                    
                    // End turn if all explosions are gone and no projectiles remain
                    if (gameState.explosions.length === 0 && gameState.projectiles.length === 0) {
                        endTurn();
                    }
                }
            }
        }
        
        // Update particles
        function updateParticles() {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                
                // Update position
                particle.x += particle.velocityX;
                particle.y += particle.velocityY;
                
                // Apply gravity to some particles
                if (!particle.type || particle.type !== 'text') {
                    particle.velocityY += 0.1;
                }
                
                // Decrease life
                particle.life--;
                
                // Update opacity near end of life
                if (particle.life < 10) {
                    particle.opacity = particle.life / 10;
                }
                
                // Remove dead particles
                if (particle.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }
        
        // Create cloud objects
        function createClouds() {
            const clouds = [];
            
            for (let i = 0; i < CLOUD_COUNT; i++) {
                clouds.push({
                    x: Math.random() * 3000,
                    y: Math.random() * 400,
                    width: 100 + Math.random() * 150,
                    height: 50 + Math.random() * 50,
                    speed: 0.2 + Math.random() * 0.3,
                    opacity: 0.6 + Math.random() * 0.2
                });
            }
            
            return clouds;
        }
        
        // Update cloud positions
        function updateClouds() {
            if (!gameState.clouds || gameState.clouds.length === 0) {
                gameState.clouds = createClouds();
            }
            
            for (const cloud of gameState.clouds) {
                // Move clouds based on wind
                cloud.x += parseFloat(gameState.wind) * 0.1;
                
                // Wrap clouds around the map
                if (cloud.x > 3000 + cloud.width) {
                    cloud.x = -cloud.width;
                } else if (cloud.x < -cloud.width) {
                    cloud.x = 3000 + cloud.width;
                }
            }
        }
        
        // End the current turn
        function endTurn() {
            // Only the active player should send turn complete
            if (gameState.currentTurn === gameState.playerId) {
                socket.emit('turn-complete');
            }
        }
        
        // Render the game
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
            
            // Only render if in game
            if (gameState.screen !== 'game') return;
            
            const canvasWidth = gameCanvas.width / (window.devicePixelRatio || 1);
            const canvasHeight = gameCanvas.height / (window.devicePixelRatio || 1);
            
            // Calculate camera bounds
            const cameraX = Math.min(Math.max(gameState.camera.x - canvasWidth / 2, 0), 3000 - canvasWidth);
            const cameraY = Math.min(Math.max(gameState.camera.y - canvasHeight / 2, 0), 1500 - canvasHeight);
            
            // Draw sky background
            drawSky();
            
            // Draw clouds
            drawClouds(cameraX, cameraY);
            
            // Draw terrain
            drawTerrain(cameraX, cameraY);
            
            // Draw platforms
            drawPlatforms(cameraX, cameraY);
            
            // Draw powerups
            drawPowerups(cameraX, cameraY);
            
            // Draw players
            drawPlayers(cameraX, cameraY);
            
            // Draw projectiles
            drawProjectiles(cameraX, cameraY);
            
            // Draw explosions
            drawExplosions(cameraX, cameraY);
            
            // Draw particles
            drawParticles(cameraX, cameraY);
            
            // Draw UI elements on uiCanvas
            drawUI();
        }
        
        // Draw sky gradient background
        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
            
            if (document.documentElement.classList.contains('dark')) {
                // Night sky
                gradient.addColorStop(0, '#0F2027');
                gradient.addColorStop(0.5, '#203A43');
                gradient.addColorStop(1, '#2C5364');
            } else {
                // Day sky
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.7, '#E0F7FF');
                gradient.addColorStop(1, '#FFF9C4');
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            
            // Add a sun or moon
            if (document.documentElement.classList.contains('dark')) {
                // Moon
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(gameCanvas.width * 0.8, gameCanvas.height * 0.2, 40, 0, Math.PI * 2);
                ctx.fill();
                
                // Moon craters
                ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
                ctx.beginPath();
                ctx.arc(gameCanvas.width * 0.8 - 15, gameCanvas.height * 0.2 - 10, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(gameCanvas.width * 0.8 + 10, gameCanvas.height * 0.2 + 5, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Stars
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * gameCanvas.width;
                    const y = Math.random() * gameCanvas.height * 0.6;
                    const size = Math.random() * 2 + 1;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.random() * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // Sun
                const sunGradient = ctx.createRadialGradient(
                    gameCanvas.width * 0.2,
                    gameCanvas.height * 0.2,
                    0,
                    gameCanvas.width * 0.2,
                    gameCanvas.height * 0.2,
                    60
                );
                
                sunGradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
                sunGradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.8)');
                sunGradient.addColorStop(1, 'rgba(255, 150, 50, 0)');
                
                ctx.fillStyle = sunGradient;
                ctx.beginPath();
                ctx.arc(gameCanvas.width * 0.2, gameCanvas.height * 0.2, 60, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw clouds
        function drawClouds(cameraX, cameraY) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            
            for (const cloud of gameState.clouds) {
                const screenX = cloud.x - cameraX;
                const screenY = cloud.y - cameraY;
                
                if (screenX < -cloud.width || screenX > gameCanvas.width / (window.devicePixelRatio || 1) ||
                    screenY < -cloud.height || screenY > gameCanvas.height / (window.devicePixelRatio || 1)) {
                    continue;
                }
                
                ctx.save();
                ctx.globalAlpha = cloud.opacity;
                
                // Draw fluffy cloud shape
                ctx.beginPath();
                const radius = cloud.height / 2;
                
                // Cloud main body
                ctx.arc(screenX + radius, screenY + radius, radius, 0, Math.PI * 2);
                ctx.arc(screenX + cloud.width - radius, screenY + radius, radius, 0, Math.PI * 2);
                
                // Cloud top bumps
                const bumps = Math.floor(cloud.width / 40);
                for (let i = 1; i < bumps; i++) {
                    const bumpX = screenX + (cloud.width * i / bumps);
                    const bumpY = screenY + (Math.sin(i * 0.7) * 10);
                    const bumpRadius = 20 + Math.random() * 20;
                    ctx.arc(bumpX, bumpY, bumpRadius, 0, Math.PI * 2);
                }
                
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Draw terrain
        function drawTerrain(cameraX, cameraY) {
            if (!gameState.terrain || gameState.terrain.length < 2) return;
            
            // Draw terrain fill
            const terrainColor = document.documentElement.classList.contains('dark') ? '#3E2723' : '#8B4513';
            const terrainGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
            terrainGradient.addColorStop(0, terrainColor);
            terrainGradient.addColorStop(1, document.documentElement.classList.contains('dark') ? '#1B0000' : '#5D4037');
            
            ctx.fillStyle = terrainGradient;
            ctx.beginPath();
            
            const firstPoint = gameState.terrain[0];
            ctx.moveTo(firstPoint.x - cameraX, firstPoint.y - cameraY);
            
            for (let i = 1; i < gameState.terrain.length; i++) {
                const point = gameState.terrain[i];
                ctx.lineTo(point.x - cameraX, point.y - cameraY);
            }
            
            // Complete the shape by extending to bottom corners
            const lastPoint = gameState.terrain[gameState.terrain.length - 1];
            ctx.lineTo(lastPoint.x - cameraX, gameCanvas.height);
            ctx.lineTo(firstPoint.x - cameraX, gameCanvas.height);
            ctx.closePath();
            ctx.fill();
            
            // Draw grass on top of terrain
            const grassColor = document.documentElement.classList.contains('dark') ? '#33691E' : '#558B2F';
            ctx.strokeStyle = grassColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(firstPoint.x - cameraX, firstPoint.y - cameraY);
            
            for (let i = 1; i < gameState.terrain.length; i++) {
                const point = gameState.terrain[i];
                ctx.lineTo(point.x - cameraX, point.y - cameraY);
            }
            
            ctx.stroke();
            
            // Add grass tufts for detail
            ctx.strokeStyle = document.documentElement.classList.contains('dark') ? '#4CAF50' : '#7CB342';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < gameState.terrain.length; i += 5) {
                const point = gameState.terrain[i];
                const screenX = point.x - cameraX;
                const screenY = point.y - cameraY;
                
                if (screenX < -20 || screenX > gameCanvas.width / (window.devicePixelRatio || 1) + 20 ||
                    screenY < -20 || screenY > gameCanvas.height / (window.devicePixelRatio || 1) + 20) {
                    continue;
                }
                
                // Draw grass tufts
                for (let j = 0; j < 3; j++) {
                    const offsetX = (Math.random() - 0.5) * 10;
                    const height = 3 + Math.random() * 7;
                    
                    ctx.beginPath();
                    ctx.moveTo(screenX + offsetX, screenY);
                    ctx.lineTo(screenX + offsetX, screenY - height);
                    ctx.stroke();
                }
            }
        }
        
        // Draw platforms
        function drawPlatforms(cameraX, cameraY) {
            if (!gameState.platforms || gameState.platforms.length === 0) return;
            
            for (const platform of gameState.platforms) {
                const screenX = platform.x - cameraX;
                const screenY = platform.y - cameraY;
                
                if (screenX + platform.width < 0 || screenX > gameCanvas.width / (window.devicePixelRatio || 1) ||
                    screenY + platform.height < 0 || screenY > gameCanvas.height / (window.devicePixelRatio || 1)) {
                    continue;
                }
                
                // Draw platform with enhanced graphics
                const platformColor = document.documentElement.classList.contains('dark') ? '#5D4037' : '#8D6E63';
                
                // Platform gradient
                const platformGradient = ctx.createLinearGradient(screenX, screenY, screenX, screenY + platform.height);
                platformGradient.addColorStop(0, platformColor);
                platformGradient.addColorStop(1, document.documentElement.classList.contains('dark') ? '#3E2723' : '#6D4C41');
                
                ctx.fillStyle = platformGradient;
                
                // Draw with rounded corners
                ctx.beginPath();
                const radius = 10;
                ctx.moveTo(screenX + radius, screenY);
                ctx.lineTo(screenX + platform.width - radius, screenY);
                ctx.arc(screenX + platform.width - radius, screenY + radius, radius, -Math.PI / 2, 0);
                ctx.lineTo(screenX + platform.width, screenY + platform.height - radius);
                ctx.arc(screenX + platform.width - radius, screenY + platform.height - radius, radius, 0, Math.PI / 2);
                ctx.lineTo(screenX + radius, screenY + platform.height);
                ctx.arc(screenX + radius, screenY + platform.height - radius, radius, Math.PI / 2, Math.PI);
                ctx.lineTo(screenX, screenY + radius);
                ctx.arc(screenX + radius, screenY + radius, radius, Math.PI, Math.PI * 3 / 2);
                ctx.closePath();
                ctx.fill();
                
                // Draw platform outline
                ctx.strokeStyle = document.documentElement.classList.contains('dark') ? '#4E342E' : '#A1887F';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw grass on top
                const grassColor = document.documentElement.classList.contains('dark') ? '#33691E' : '#558B2F';
                ctx.strokeStyle = grassColor;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(screenX + radius/2, screenY);
                ctx.lineTo(screenX + platform.width - radius/2, screenY);
                ctx.stroke();
                
                // Add grass tufts
                ctx.strokeStyle = document.documentElement.classList.contains('dark') ? '#4CAF50' : '#7CB342';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < platform.width; i += 15) {
                    const offsetX = screenX + i + (Math.random() - 0.5) * 5;
                    const height = 2 + Math.random() * 5;
                    
                    ctx.beginPath();
                    ctx.moveTo(offsetX, screenY);
                    ctx.lineTo(offsetX, screenY - height);
                    ctx.stroke();
                }
            }
        }
        
        // Draw powerups
        function drawPowerups(cameraX, cameraY) {
            if (!gameState.powerups || gameState.powerups.length === 0) return;
            
            for (const powerup of gameState.powerups) {
                const screenX = powerup.x - cameraX;
                const screenY = powerup.y - cameraY;
                
                if (screenX < -50 || screenX > gameCanvas.width / (window.devicePixelRatio || 1) + 50 ||
                    screenY < -50 || screenY > gameCanvas.height / (window.devicePixelRatio || 1) + 50) {
                    continue;
                }
                
                // Draw powerup glow with pulsating effect
                ctx.save();
                const pulseAmount = 0.5 + Math.sin(Date.now() * 0.005) * 0.2;
                ctx.globalAlpha = pulseAmount;
                
                const gradient = ctx.createRadialGradient(
                    screenX, screenY, 0,
                    screenX, screenY, 30
                );
                
                let color;
                switch (powerup.type) {
                    case 'health': color = '#4CAF50'; break;
                    case 'ammo': color = '#FFC107'; break;
                    case 'shield': color = '#2196F3'; break;
                    default: color = '#9C27B0';
                }
                
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw powerup icon
                ctx.globalAlpha = 1;
                ctx.font = 'bold 24px Nunito';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                let icon;
                switch (powerup.type) {
                    case 'health': icon = '❤️'; break;
                    case 'ammo': icon = '🎯'; break;
                    case 'shield': icon = '🛡️'; break;
                    default: icon = '✨';
                }
                
                ctx.fillText(icon, screenX, screenY);
                
                // Draw floating animation
                const floatOffset = Math.sin(Date.now() * 0.003) * 5;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(screenX, screenY + 20 + floatOffset, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Draw players
        function drawPlayers(cameraX, cameraY) {
            for (const player of gameState.players) {
                if (!player.alive) continue;
                
                const screenX = player.x - cameraX;
                const screenY = player.y - cameraY;
                
                if (screenX < -50 || screenX > gameCanvas.width / (window.devicePixelRatio || 1) + 50 ||
                    screenY < -50 || screenY > gameCanvas.height / (window.devicePixelRatio || 1) + 50) {
                    continue;
                }
                
                // Draw player
                const character = gameState.characters.find(c => c.id === player.character);
                
                if (!character) continue;
                
                // Draw shield effect if present
                const shieldEffect = player.effects.find(e => e.type === 'shield');
                if (shieldEffect) {
                    ctx.save();
                    ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.005) * 0.1;
                    
                    // Outer glow
                    const shieldGradient = ctx.createRadialGradient(
                        screenX, screenY, 30,
                        screenX, screenY, 45
                    );
                    
                    shieldGradient.addColorStop(0, 'rgba(100, 181, 246, 0.2)');
                    shieldGradient.addColorStop(1, 'rgba(100, 181, 246, 0)');
                    
                    ctx.fillStyle = shieldGradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 45, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Shield border
                    ctx.strokeStyle = '#64B5F6';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 40, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                // Determine facing direction based on angle or last projectile
                let facingLeft = false;
                
                if (player.id === gameState.playerId && gameState.isMyTurn) {
                    facingLeft = gameState.angle > 90 && gameState.angle < 270;
                } else if (gameState.projectiles.length > 0 && gameState.projectiles[0].ownerId === player.id) {
                    facingLeft = gameState.projectiles[0].velocityX < 0;
                }
                
                // Draw player with character-specific appearance
                ctx.save();
                
                // Character base
                ctx.fillStyle = character.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Character details (eyes, etc.)
                ctx.fillStyle = 'white';
                
                // Eyes position based on facing direction
                const eyeOffsetX = facingLeft ? -5 : 5;
                
                // Left/right eye
                ctx.beginPath();
                ctx.arc(screenX + eyeOffsetX, screenY - 5, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupil
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(screenX + eyeOffsetX + (facingLeft ? -2 : 2), screenY - 5, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Character-specific details
                switch (character.id) {
                    case 'tank':
                        // Draw tank hat
                        ctx.fillStyle = '#4A4A4A';
                        ctx.beginPath();
                        ctx.ellipse(screenX, screenY - 15, 20, 8, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'scout':
                        // Draw scout hat
                        ctx.fillStyle = '#33691E';
                        ctx.beginPath();
                        ctx.moveTo(screenX - 15, screenY - 10);
                        ctx.lineTo(screenX + 15, screenY - 10);
                        ctx.lineTo(screenX, screenY - 25);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case 'heavy':
                        // Draw heavy armor
                        ctx.fillStyle = '#1565C0';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 25, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Redraw character base
                        ctx.fillStyle = character.color;
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 20, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Redraw eyes
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(screenX + eyeOffsetX, screenY - 5, 5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(screenX + eyeOffsetX + (facingLeft ? -2 : 2), screenY - 5, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'wind':
                        // Wind swirls
                        ctx.strokeStyle = '#B3E5FC';
                        ctx.lineWidth = 2;
                        
                        for (let i = 0; i < 3; i++) {
                            const swirl = (Date.now() / 1000 + i) % 3;
                            const swirl2 = (Date.now() / 800 + i) % 3;
                            
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, 25 + swirl * 5, 0, Math.PI * 1.2);
                            ctx.stroke();
                            
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, 25 + swirl2 * 5, Math.PI, Math.PI * 2.2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'robot':
                        // Robot antenna
                        ctx.fillStyle = '#9E9E9E';
                        ctx.fillRect(screenX - 2, screenY - 25, 4, 10);
                        
                        ctx.fillStyle = '#F44336';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY - 28, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Robot panel lines
                        ctx.strokeStyle = '#424242';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(screenX - 10, screenY + 5);
                        ctx.lineTo(screenX + 10, screenY + 5);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY - 10);
                        ctx.lineTo(screenX, screenY + 10);
                        ctx.stroke();
                        break;
                        
                    case 'chicken':
                        // Chicken comb
                        ctx.fillStyle = '#F44336';
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY - 20);
                        ctx.lineTo(screenX - 5, screenY - 25);
                        ctx.lineTo(screenX, screenY - 30);
                        ctx.lineTo(screenX + 5, screenY - 25);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Chicken beak
                        ctx.fillStyle = '#FF9800';
                        ctx.beginPath();
                        ctx.moveTo(screenX + (facingLeft ? -20 : 20), screenY);
                        ctx.lineTo(screenX + (facingLeft ? -10 : 10), screenY - 5);
                        ctx.lineTo(screenX + (facingLeft ? -10 : 10), screenY + 5);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                
                ctx.restore();
                
                // Draw character icon above for clarity
                ctx.font = 'bold 16px Nunito';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'white';
                ctx.fillText(character.icon, screenX, screenY - 30);
                
                // Draw weapon if current turn
                if (player.id === gameState.currentTurn) {
                    // Determine aim direction
                    let angle;
                    
                    if (player.id === gameState.playerId) {
                        angle = gameState.angle * Math.PI / 180;
                        if (facingLeft) {
                            angle = Math.PI - angle;
                        }
                    } else {
                        // For other players, just show a default angle
                        angle = facingLeft ? Math.PI - Math.PI/4 : Math.PI/4;
                    }
                    
                    const weaponLength = 30;
                    const weaponEndX = screenX + Math.cos(angle) * weaponLength;
                    const weaponEndY = screenY - Math.sin(angle) * weaponLength;
                    
                    // Draw weapon base
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(weaponEndX, weaponEndY);
                    ctx.stroke();
                    
                    // Draw weapon tip based on selected weapon
                    if (player.id === gameState.playerId) {
                        const weaponType = gameState.selectedWeapon;
                        
                        switch (weaponType) {
                            case 'basic':
                                // Basic cannon tip
                                ctx.fillStyle = '#555';
                                ctx.beginPath();
                                ctx.arc(weaponEndX, weaponEndY, 5, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                                
                            case 'missile':
                                // Missile launcher
                                ctx.fillStyle = '#F44336';
                                ctx.beginPath();
                                ctx.moveTo(weaponEndX, weaponEndY);
                                ctx.lineTo(weaponEndX + Math.cos(angle) * 10, weaponEndY - Math.sin(angle) * 10);
                                ctx.lineTo(weaponEndX + Math.cos(angle) * 10 + Math.cos(angle + Math.PI/2) * 3, weaponEndY - Math.sin(angle) * 10 - Math.sin(angle + Math.PI/2) * 3);
                                ctx.lineTo(weaponEndX + Math.cos(angle + Math.PI/2) * 3, weaponEndY - Math.sin(angle + Math.PI/2) * 3);
                                ctx.closePath();
                                ctx.fill();
                                break;
                                
                            case 'laser':
                                // Laser pointer
                                ctx.fillStyle = '#00BCD4';
                                ctx.strokeStyle = '#00BCD4';
                                ctx.lineWidth = 1;
                                
                                // Draw laser beam indicator
                                ctx.beginPath();
                                ctx.moveTo(weaponEndX, weaponEndY);
                                ctx.lineTo(weaponEndX + Math.cos(angle) * 100, weaponEndY - Math.sin(angle) * 100);
                                ctx.stroke();
                                
                                // Laser tip
                                ctx.beginPath();
                                ctx.arc(weaponEndX, weaponEndY, 4, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                                
                            default:
                                // Generic weapon tip
                                ctx.fillStyle = '#555';
                                ctx.beginPath();
                                ctx.arc(weaponEndX, weaponEndY, 5, 0, Math.PI * 2);
                                ctx.fill();
                        }
                        
                        // Draw power indicator
                        const powerIndicatorLength = (gameState.power / MAX_POWER) * 60;
                        
                        ctx.strokeStyle = 'rgba(255, 152, 0, 0.7)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(weaponEndX, weaponEndY);
                        ctx.lineTo(
                            weaponEndX + Math.cos(angle) * powerIndicatorLength,
                            weaponEndY - Math.sin(angle) * powerIndicatorLength
                        );
                        ctx.stroke();
                    } else {
                        // Generic weapon tip for other players
                        ctx.fillStyle = '#555';
                        ctx.beginPath();
                        ctx.arc(weaponEndX, weaponEndY, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Draw player name above
                ctx.font = '14px Nunito';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(player.name, screenX, screenY - 50);
                ctx.fillText(player.name, screenX, screenY - 50);
                
                // Draw health bar with improved look
                const healthBarWidth = 60;
                const healthBarHeight = 8;
                const healthPercent = player.health / player.maxHealth;
                
                // Health bar container
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(
                    screenX - healthBarWidth / 2,
                    screenY - 40,
                    healthBarWidth,
                    healthBarHeight
                );
                
                // Health bar border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(
                    screenX - healthBarWidth / 2,
                    screenY - 40,
                    healthBarWidth,
                    healthBarHeight
                );
                
                // Health bar fill with gradient based on health percentage
                const healthGradient = ctx.createLinearGradient(
                    screenX - healthBarWidth / 2,
                    screenY - 40,
                    screenX - healthBarWidth / 2 + healthBarWidth * healthPercent,
                    screenY - 40
                );
                
                if (healthPercent > 0.5) {
                    healthGradient.addColorStop(0, '#4CAF50');
                    healthGradient.addColorStop(1, '#8BC34A');
                } else if (healthPercent > 0.25) {
                    healthGradient.addColorStop(0, '#FFC107');
                    healthGradient.addColorStop(1, '#FFD54F');
                } else {
                    healthGradient.addColorStop(0, '#F44336');
                    healthGradient.addColorStop(1, '#E57373');
                }
                
                ctx.fillStyle = healthGradient;
                ctx.fillRect(
                    screenX - healthBarWidth / 2,
                    screenY - 40,
                    healthBarWidth * healthPercent,
                    healthBarHeight
                );
                
                // Health text
                ctx.font = '10px Nunito';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'white';
                ctx.fillText(`${player.health}/${player.maxHealth}`, screenX, screenY - 40 + healthBarHeight / 2 + 1);
                
                // Turn indicator for current player
                if (player.id === gameState.currentTurn) {
                    // Animated turn indicator
                    const pulseSize = 1 + Math.sin(Date.now() * 0.01) * 0.1;
                    
                    ctx.fillStyle = '#4CAF50';
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY - 60 * pulseSize);
                    ctx.lineTo(screenX - 10 * pulseSize, screenY - 50 * pulseSize);
                    ctx.lineTo(screenX + 10 * pulseSize, screenY - 50 * pulseSize);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw border
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }
        
        // Draw projectiles
        function drawProjectiles(cameraX, cameraY) {
            for (const proj of gameState.projectiles) {
                const screenX = proj.x - cameraX;
                const screenY = proj.y - cameraY;
                
                if (screenX < -50 || screenX > gameCanvas.width / (window.devicePixelRatio || 1) + 50 ||
                    screenY < -50 || screenY > gameCanvas.height / (window.devicePixelRatio || 1) + 50) {
                    continue;
                }
                
                // Draw projectile based on type
                switch (proj.type) {
                    case 'basic':
                        // Draw basic bomb
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw fuse
                        ctx.strokeStyle = '#FFA000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY - 8);
                        ctx.lineTo(screenX, screenY - 15);
                        ctx.stroke();
                        
                        // Draw spark
                        if (Math.random() > 0.5) {
                            ctx.fillStyle = '#FFF176';
                            ctx.beginPath();
                            ctx.arc(screenX, screenY - 15, 2 + Math.random() * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    
                    case 'missile':
                        // Draw missile body
                        ctx.save();
                        
                        // Rotate in direction of movement
                        const angle = Math.atan2(proj.velocityY, proj.velocityX);
                        ctx.translate(screenX, screenY);
                        ctx.rotate(angle);
                        
                        // Missile body
                        ctx.fillStyle = '#F44336';
                        ctx.beginPath();
                        ctx.moveTo(10, 0);
                        ctx.lineTo(-10, -5);
                        ctx.lineTo(-10, 5);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Missile fins
                        ctx.fillStyle = '#B71C1C';
                        ctx.beginPath();
                        ctx.moveTo(-8, 0);
                        ctx.lineTo(-15, -8);
                        ctx.lineTo(-10, -8);
                        ctx.lineTo(-10, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.moveTo(-8, 0);
                        ctx.lineTo(-15, 8);
                        ctx.lineTo(-10, 8);
                        ctx.lineTo(-10, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Exhaust flame
                        if (Math.random() > 0.3) {
                            ctx.fillStyle = '#FFA000';
                            ctx.beginPath();
                            ctx.moveTo(-10, 0);
                            ctx.lineTo(-20 - Math.random() * 10, -3 - Math.random() * 2);
                            ctx.lineTo(-20 - Math.random() * 10, 3 + Math.random() * 2);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        ctx.restore();
                        break;
                    
                    case 'laser':
                        // Draw laser beam
                        ctx.save();
                        
                        // Rotate in direction of movement
                        const laserAngle = Math.atan2(proj.velocityY, proj.velocityX);
                        ctx.translate(screenX, screenY);
                        ctx.rotate(laserAngle);
                        
                        // Create laser gradient
                        const laserGradient = ctx.createLinearGradient(-30, 0, 30, 0);
                        laserGradient.addColorStop(0, 'rgba(0, 188, 212, 0)');
                        laserGradient.addColorStop(0.2, 'rgba(0, 188, 212, 0.8)');
                        laserGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                        laserGradient.addColorStop(0.8, 'rgba(0, 188, 212, 0.8)');
                        laserGradient.addColorStop(1, 'rgba(0, 188, 212, 0)');
                        
                        // Laser beam
                        ctx.fillStyle = laserGradient;
                        ctx.fillRect(-30, -2, 60, 4);
                        
                        // Core
                        ctx.fillStyle = 'white';
                        ctx.fillRect(-20, -1, 40, 2);
                        
                        ctx.restore();
                        break;
                    
                    case 'tornado':
                        // Draw tornado swirl
                        ctx.save();
                        
                        // Rotate based on time for spinning effect
                        const tornadoAngle = Date.now() * 0.01;
                        ctx.translate(screenX, screenY);
                        ctx.rotate(tornadoAngle);
                        
                        // Draw swirls
                        for (let i = 0; i < 3; i++) {
                            const radius = 8 + i * 4;
                            const startAngle = i * Math.PI * 0.5;
                            
                            ctx.strokeStyle = `rgba(3, 169, 244, ${0.8 - i * 0.2})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius, startAngle, startAngle + Math.PI * 1.5);
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                        break;
                    
                    case 'shotgun':
                        // Draw shotgun pellets
                        for (let i = 0; i < 3; i++) {
                            const offsetX = (i - 1) * 5;
                            const offsetY = (i - 1) * 2;
                            
                            ctx.fillStyle = '#795548';
                            ctx.beginPath();
                            ctx.arc(screenX + offsetX, screenY + offsetY, 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    
                    case 'axe':
                        // Draw spinning axe
                        ctx.save();
                        
                        // Rotate based on velocity and time
                        const axeAngle = Math.atan2(proj.velocityY, proj.velocityX) + Date.now() * 0.01;
                        ctx.translate(screenX, screenY);
                        ctx.rotate(axeAngle);
                        
                        // Axe head
                        ctx.fillStyle = '#E91E63';
                        ctx.beginPath();
                        ctx.moveTo(8, -10);
                        ctx.lineTo(15, -5);
                        ctx.lineTo(15, 5);
                        ctx.lineTo(8, 10);
                        ctx.lineTo(0, 5);
                        ctx.lineTo(0, -5);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Axe handle
                        ctx.fillStyle = '#795548';
                        ctx.fillRect(-15, -2, 15, 4);
                        
                        ctx.restore();
                        break;
                    
                    case 'vine':
                        // Draw vine projectile
                        ctx.save();
                        
                        // Rotate in direction of movement
                        const vineAngle = Math.atan2(proj.velocityY, proj.velocityX);
                        ctx.translate(screenX, screenY);
                        ctx.rotate(vineAngle);
                        
                        // Vine body
                        ctx.strokeStyle = '#4CAF50';
                        ctx.lineWidth = 3;
                        
                        // Wavy vine
                        ctx.beginPath();
                        ctx.moveTo(-15, 0);
                        ctx.quadraticCurveTo(-10, -8, 0, 0);
                        ctx.quadraticCurveTo(10, 8, 15, 0);
                        ctx.stroke();
                        
                        // Vine leaves
                        ctx.fillStyle = '#8BC34A';
                        ctx.beginPath();
                        ctx.ellipse(0, -5, 5, 3, Math.PI/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(10, 2, 4, 2, Math.PI/3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                        break;
                    
                    case 'egg':
                        // Draw egg projectile
                        ctx.save();
                        
                        // Wobble rotation based on time
                        const eggAngle = Math.sin(Date.now() * 0.01) * 0.2;
                        ctx.translate(screenX, screenY);
                        ctx.rotate(eggAngle);
                        
                        // Egg shape
                        ctx.fillStyle = '#FFF9C4';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 10, 12, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Egg spots
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.beginPath();
                        ctx.ellipse(3, -3, 3, 2, Math.PI/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(-4, 2, 2, 1, Math.PI/3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                        break;
                    
                    default:
                        // Default projectile
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 6, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
            }
        }
        
        // Draw explosions
        function drawExplosions(cameraX, cameraY) {
            for (const explosion of gameState.explosions) {
                const screenX = explosion.x - cameraX;
                const screenY = explosion.y - cameraY;
                
                if (screenX < -explosion.maxRadius || screenX > gameCanvas.width / (window.devicePixelRatio || 1) + explosion.maxRadius ||
                    screenY < -explosion.maxRadius || screenY > gameCanvas.height / (window.devicePixelRatio || 1) + explosion.maxRadius) {
                    continue;
                }
                
                // Draw explosion with improved appearance
                const gradient = ctx.createRadialGradient(
                    screenX, screenY, 0,
                    screenX, screenY, explosion.currentRadius
                );
                
                // Fade out as life decreases
                const opacity = Math.min(1, explosion.life / 20);
                
                // Use explosion color if provided, otherwise default colors
                const color = explosion.color || '#FF9800';
                
                gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                gradient.addColorStop(0.3, color.replace(')', `, ${opacity})`).replace('rgb', 'rgba'));
                gradient.addColorStop(0.7, `rgba(255, 100, 0, ${opacity * 0.7})`);
                gradient.addColorStop(1, `rgba(255, 0, 0, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenX, screenY, explosion.currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Add shockwave ring
                if (explosion.currentRadius > explosion.maxRadius * 0.5) {
                    const ringRadius = explosion.currentRadius * 1.2;
                    const ringWidth = 3;
                    
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
                    ctx.lineWidth = ringWidth;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Add debris particles near the explosion edge
                if (Math.random() > 0.7) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = explosion.currentRadius * 0.8;
                    
                    ctx.fillStyle = 'rgba(150, 100, 50, 0.8)';
                    ctx.beginPath();
                    ctx.arc(
                        screenX + Math.cos(angle) * distance,
                        screenY + Math.sin(angle) * distance,
                        2 + Math.random() * 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
            }
        }
        
        // Draw particles
        function drawParticles(cameraX, cameraY) {
            for (const particle of gameState.particles) {
                const screenX = particle.x - cameraX;
                const screenY = particle.y - cameraY;
                
                if (particle.type === 'text') {
                    // Draw text particles (damage numbers, etc.)
                    ctx.save();
                    ctx.globalAlpha = particle.opacity;
                    ctx.font = 'bold 18px Nunito';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = particle.color;
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(particle.text, screenX, screenY);
                    ctx.fillText(particle.text, screenX, screenY);
                    ctx.restore();
                } else {
                    // Draw regular particles
                    ctx.save();
                    ctx.globalAlpha = particle.opacity;
                    ctx.fillStyle = particle.color;
                    
                    // Draw glow for particles
                    const glow = ctx.createRadialGradient(
                        screenX, screenY, 0,
                        screenX, screenY, particle.size
                    );
                    
                    glow.addColorStop(0, particle.color);
                    glow.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    // For some particle types, add enhanced effects
                    if (particle.color === '#4CAF50') { // healing particles
                        ctx.shadowColor = '#4CAF50';
                        ctx.shadowBlur = 5;
                    } else if (particle.color === '#64B5F6') { // shield particles
                        ctx.shadowColor = '#2196F3';
                        ctx.shadowBlur = 10;
                    }
                    
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }
        
        // Draw UI elements
        function drawUI() {
            // Timer warning colors
            const timerText = document.getElementById('timerText');
            if (gameState.turnTimeRemaining <= 5) {
                timerText.classList.add('danger');
                timerText.classList.remove('warning');
            } else if (gameState.turnTimeRemaining <= 10) {
                timerText.classList.add('warning');
                timerText.classList.remove('danger');
            } else {
                timerText.classList.remove('warning');
                timerText.classList.remove('danger');
            }
            
            // Update timer text
            timerText.textContent = `${currentLanguage === 'vi' ? 'Thời gian' : 'Time'}: ${gameState.turnTimeRemaining}s`;
            
            // Update wind indicator
            document.getElementById('windText').textContent = `${currentLanguage === 'vi' ? 'Gió' : 'Wind'}: ${gameState.wind} m/s`;
            document.getElementById('windArrow').innerHTML = parseFloat(gameState.wind) > 0 ? '→' : (parseFloat(gameState.wind) < 0 ? '←' : '•');
            
            // Update turn indicator
            const turnText = document.getElementById('turnText');
            if (gameState.isMyTurn) {
                turnText.textContent = currentLanguage === 'vi' ? 'Lượt Của Bạn' : 'Your Turn';
                turnText.dataset.playerName = '';
            } else {
                const currentPlayer = gameState.players.find(p => p.id === gameState.currentTurn);
                if (currentPlayer) {
                    turnText.dataset.playerName = currentPlayer.name;
                    turnText.textContent = (currentLanguage === 'vi' ? 'Lượt của ' : '') + currentPlayer.name + (currentLanguage === 'en' ? '\'s Turn' : '');
                }
            }
            
            // Update weapon name
            updateWeaponName();
        }
        
        // Set up socket event handlers
        function setupSocketEvents() {
            socket.on('connect', () => {
                console.log('Connected to server');
                gameState.playerId = socket.id;
                
                // Join game
                socket.emit('join-game', { playerName: gameState.playerName }, (response) => {
                    if (!response.success) {
                        showToast(currentLanguage === 'vi' ? 'Không thể tham gia trò chơi: ' + response.message : 'Failed to join game: ' + response.message);
                    }
                });
            });
            
            socket.on('rooms-updated', () => {
                // Update rooms list if on room screen
                if (gameState.screen === 'roomList') {
                    fetchRooms();
                }
            });
            
            socket.on('player-joined', (data) => {
                if (gameState.roomId) {
                    // Add player to room
                    gameState.players.push(data.player);
                    
                    // Update waiting room
                    updateWaitingRoomPlayers();
                    
                    // Show notification
                    addChatMessage(null, `${data.player.name} ${currentLanguage === 'vi' ? 'đã tham gia phòng' : 'joined the room'}`, true);
                }
            });
            
            socket.on('player-left', (data) => {
                if (gameState.roomId) {
                    // Remove player from room
                    gameState.players = gameState.players.filter(p => p.id !== data.playerId);
                    
                    // Update waiting room
                    updateWaitingRoomPlayers();
                    
                    // Show notification
                    addChatMessage(null, `${data.playerName} ${currentLanguage === 'vi' ? 'đã rời phòng' : 'left the room'}`, true);
                }
            });
            
            socket.on('owner-changed', (data) => {
                if (gameState.roomId) {
                    // Update room owner
                    gameState.players.forEach(player => {
                        player.isOwner = player.id === data.owner.id;
                    });
                    
                    // Check if I'm the new owner
                    gameState.isRoomOwner = data.owner.id === gameState.playerId;
                    
                    // Update UI
                    if (gameState.isRoomOwner) {
                        document.getElementById('startGameBtn').style.display = 'block';
                        document.getElementById('mapSelectionContainer').style.display = 'block';
                    }
                    
                    // Update waiting room
                    updateWaitingRoomPlayers();
                    
                    // Show notification
                    addChatMessage(null, `${data.owner.name} ${currentLanguage === 'vi' ? 'là chủ phòng mới' : 'is now the room owner'}`, true);
                }
            });
            
            socket.on('game-started', (data) => {
                // Set up game state
                gameState.terrain = data.map.terrain;
                gameState.platforms = data.map.platforms;
                gameState.players = data.players;
                gameState.currentTurn = data.currentTurn;
                gameState.isMyTurn = data.currentTurn === gameState.playerId;
                gameState.turnTimeRemaining = data.turnTime;
                gameState.wind = data.wind;
                gameState.weapons = data.weapons;
                gameState.items = data.items;
                
                // Reset game objects
                gameState.projectiles = [];
                gameState.explosions = [];
                gameState.particles = [];
                gameState.powerups = [];
                
                // Set player facingLeft based on position
                gameState.players.forEach(player => {
                    // Players on left half face right, on right half face left
                    player.facingLeft = player.x > data.map.width / 2;
                });
                
                // Initialize camera position to own player
                const ownPlayer = gameState.players.find(p => p.id === gameState.playerId);
                if (ownPlayer) {
                    gameState.camera.x = ownPlayer.x;
                    gameState.camera.y = ownPlayer.y;
                    gameState.camera.targetX = ownPlayer.x;
                    gameState.camera.targetY = ownPlayer.y;
                    
                    // Set initial selected weapon to player's primary weapon
                    if (ownPlayer.inventory) {
                        const weapons = Object.entries(ownPlayer.inventory).filter(([_, item]) => item.type === 'weapon');
                        if (weapons.length > 0) {
                            gameState.selectedWeapon = weapons[0][0];
                        }
                    }
                }
                
                // Initialize UI positions
                positionAngleIndicator();
                positionPowerBar();
                
                // Initialize clouds
                gameState.clouds = createClouds();
                
                // Switch to game screen
                waitingRoom.style.display = 'none';
                gameUI.style.display = 'block';
                gameState.screen = 'game';
                
                // Show game started notification
                addChatMessage(null, currentLanguage === 'vi' ? 'Trò chơi đã bắt đầu!' : 'Game started!', true);
                
                // Populate inventory
                populateInventory();
                
                // Update weapon name based on selected weapon
                updateWeaponName();
            });
            
            socket.on('turn-changed', (data) => {
                // Update turn
                gameState.currentTurn = data.playerId;
                gameState.isMyTurn = data.playerId === gameState.playerId;
                gameState.wind = data.wind;
                gameState.turnTimeRemaining = data.turnTime || TURN_TIME;
                
                // Reset teleport and move modes
                gameState.teleportMode = false;
                gameState.moveMode = false;
                teleportOverlay.style.display = 'none';
                teleportCrosshair.style.display = 'none';
                moveOverlay.style.display = 'none';
                
                // Focus camera on current player
                const currentPlayer = gameState.players.find(p => p.id === data.playerId);
                if (currentPlayer) {
                    gameState.camera.targetX = currentPlayer.x;
                    gameState.camera.targetY = currentPlayer.y;
                }
                
                // Reduce duration of effects
                gameState.players.forEach(player => {
                    player.effects = player.effects.filter(effect => {
                        if (effect.duration > 0) {
                            effect.duration--;
                            return true;
                        }
                        return false;
                    });
                });
                
                // Show turn change notification
                const playerName = currentPlayer ? currentPlayer.name : 'Unknown player';
                addChatMessage(null, `${currentLanguage === 'vi' ? 'Lượt của' : ''} ${playerName} ${currentLanguage === 'en' ? '\'s turn' : ''}`, true);
                
                // Reset angle and power for new turn
                if (gameState.isMyTurn) {
                    gameState.angle = 45;
                    gameState.power = 50;
                    
                    updateAngleUI();
                    updatePowerUI();
                }
            });
            
            socket.on('turn-time-update', (data) => {
                if (data.currentTurn === gameState.currentTurn) {
                    gameState.turnTimeRemaining = data.remainingTime;
                }
            });
            
            socket.on('projectile-update', (data) => {
                // For this simplified implementation, projectiles are handled client-side
            });
            
            socket.on('player-moved', (data) => {
                // Update player position
                const player = gameState.players.find(p => p.id === data.playerId);
                if (player) {
                    player.x = data.x;
                    player.y = data.y;
                    
                    // If it's the current player's move, update camera
                    if (data.playerId === gameState.currentTurn) {
                        gameState.camera.targetX = data.x;
                        gameState.camera.targetY = data.y;
                    }
                }
            });
            
            socket.on('player-damaged', (data) => {
                // Update player health
                const player = gameState.players.find(p => p.id === data.playerId);
                if (player) {
                    player.health = data.health;
                    
                    // Create damage number indicator
                    createDamageNumber(player.x, player.y - 20, data.damage);
                }
            });
            
            socket.on('player-killed', (data) => {
                // Mark player as dead
                const player = gameState.players.find(p => p.id === data.playerId);
                if (player) {
                    player.alive = false;
                    
                    // Create death effect
                    gameState.particles.push(...createDeathEffect(player.x, player.y));
                    
                    // Show notification
                    addChatMessage(null, `${player.name} ${currentLanguage === 'vi' ? 'đã bị loại khỏi trận đấu' : 'was eliminated'}`, true);
                }
            });
            
            socket.on('player-eliminated', (data) => {
                // Mark player as dead
                const player = gameState.players.find(p => p.id === data.playerId);
                if (player) {
                    player.alive = false;
                    
                    let message;
                    if (data.reason === 'missed_turns') {
                        message = currentLanguage === 'vi' 
                            ? `${player.name} đã bỏ lỡ quá nhiều lượt và bị loại` 
                            : `${player.name} missed too many turns and was eliminated`;
                    } else {
                        message = currentLanguage === 'vi' 
                            ? `${player.name} đã bị loại khỏi trận đấu` 
                            : `${player.name} was eliminated`;
                    }
                    
                    addChatMessage(null, message, true);
                }
            });
            
            socket.on('item-used', (data) => {
                // Update player state after item use
                const player = gameState.players.find(p => p.id === data.playerId);
                if (player) {
                    // Update player state with received data
                    if (data.playerState) {
                        player.health = data.playerState.health;
                        player.effects = data.playerState.effects;
                        
                        // Update position if teleport or movement happened
                        if (data.playerState.x !== undefined && data.playerState.y !== undefined) {
                            player.x = data.playerState.x;
                            player.y = data.playerState.y;
                        }
                    }
                    
                    // Create visual effects based on item used
                    switch (data.itemId) {
                        case 'healthpack':
                            gameState.particles.push(...createHealingEffect(player.x, player.y));
                            break;
                        case 'shield':
                            gameState.particles.push(...createShieldEffect(player.x, player.y));
                            break;
                        case 'teleport':
                            gameState.particles.push(...createTeleportEffect(player.x, player.y));
                            break;
                    }
                    
                    // Show notification
                    let itemName = '';
                    if (gameState.items && gameState.items[data.itemId]) {
                        itemName = currentLanguage === 'vi' ? gameState.items[data.itemId].viName : gameState.items[data.itemId].name;
                    } else {
                        itemName = data.itemId;
                    }
                    
                    addChatMessage(null, `${player.name} ${currentLanguage === 'vi' ? 'đã sử dụng' : 'used'} ${itemName}`, true);
                }
            });
            
            socket.on('terrain-modified', (data) => {
                // Update terrain
                if (data.terrain) {
                    gameState.terrain = data.terrain;
                }
                
                // Update platforms if provided
                if (data.platforms) {
                    gameState.platforms = data.platforms;
                }
            });
            
            socket.on('chat-message', (data) => {
                addChatMessage(data.sender, data.message);
            });
            
            socket.on('all-players-ready', () => {
                // Notification that all players are ready for a new game
                addChatMessage(null, currentLanguage === 'vi' ? 'Tất cả người chơi đã sẵn sàng. Bắt đầu trò chơi mới...' : 'All players are ready. Starting new game...', true);
            });
            
            socket.on('game-over', (data) => {
                // Show game over screen
                const winner = data.winner;
                
                document.getElementById('gameOverTitle').textContent = 
                    winner && winner.id === gameState.playerId 
                        ? (currentLanguage === 'vi' ? 'Chiến Thắng!' : 'Victory!') 
                        : (currentLanguage === 'vi' ? 'Thất Bại!' : 'Defeat!');
                
                document.getElementById('winnerInfo').textContent = 
                    winner 
                        ? (currentLanguage === 'vi' ? `${winner.name} đã thắng trận đấu!` : `${winner.name} won the match!`) 
                        : (currentLanguage === 'vi' ? 'Không có người thắng cuộc!' : 'No winner!');
                
                gameOverScreen.style.display = 'flex';
            });
            
            socket.on('disconnect', () => {
                showToast(currentLanguage === 'vi' ? 'Mất kết nối tới máy chủ' : 'Disconnected from server');
                
                // Go back to menu
                if (gameState.screen === 'game' || gameState.screen === 'waiting') {
                    menuScreen.style.display = 'flex';
                    waitingRoom.style.display = 'none';
                    gameUI.style.display = 'none';
                    gameState.screen = 'menu';
                }
            });
        }
        
        // Initialize the game
        init();
    </script>
</body>
</html>
